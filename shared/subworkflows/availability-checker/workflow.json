{
  "nodes": [
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "services"
            },
            {
              "name": "service_info"
            },
            {
              "name": "date_info"
            },
            {
              "name": "constraints"
            },
            {
              "name": "current_time"
            },
            {
              "name": "telefon"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -160,
        256
      ],
      "id": "1284d1d1-4cf2-4e25-ad2d-9e0254ebe058",
      "name": "availability_checker"
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// SUBWORKFLOW: availability_checker (GROUP BOOKING SUPPORT)\n// CODE NODE - Kombinasyon Üretimi ve Puanlama\n// ✅ GRUP RANDEVU DESTEĞİ EKLENDİ\n// ✅ PARALEL/SEQUENTIAL ALGILAMA\n// ✅ AYNI UZMAN OTOMATİK TESPİT\n// ============================================\n\n// ============================================\n// BÖLÜM 1: YARDIMCI FONKSİYONLAR (Mevcut - Değişiklik Yok)\n// ============================================\n\nfunction parseTurkishDate(dateStr) {\n  const [day, month, year] = (dateStr || '').split('/').map(Number);\n  return new Date(year, month - 1, day);\n}\n\nfunction formatTurkishDate(date) {\n  const day = String(date.getDate()).padStart(2, '0');\n  const month = String(date.getMonth() + 1).padStart(2, '0');\n  const year = date.getFullYear();\n  return `${day}/${month}/${year}`;\n}\n\nfunction getDayName(date) {\n  const days = ['Pazar', 'Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi'];\n  return days[date.getDay()];\n}\n\nfunction timeToMinutes(time) {\n  const [h, m] = (time || '00:00').split(':').map(Number);\n  return h * 60 + (m || 0);\n}\n\nfunction minutesToTime(minutes) {\n  const hours = Math.floor(minutes / 60);\n  const mins = minutes % 60;\n  return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;\n}\n\nfunction addMinutes(time, minutes) {\n  return minutesToTime(timeToMinutes(time) + minutes);\n}\n\nfunction normalizeExpertName(name) {\n  if (!name) return '';\n  const first = name.trim().split(' ')[0];\n  return first.toLowerCase()\n    .replace('ı', 'i').replace('ğ', 'g').replace('ü', 'u')\n    .replace('ş', 's').replace('ö', 'o').replace('ç', 'c');\n}\n\nfunction normalizeServiceName(name) {\n  if (!name) return \"\";\n  let n = String(name).trim();\n  n = n.replace(/Tırnak Çıkartma/gi, \"Tırnak Çıkarma\");\n  n = n.replace(/Ayak Kalıcı$/gi, \"Ayak Kalıcı Oje\");\n  return n;\n}\n\nfunction canonicalExpert(name){\n  if (!name) return '';\n  const norm = normalizeExpertName(name);\n  const matchKey = Object.keys(EXPERT_RULES || {})\n    .find(k => normalizeExpertName(k) === norm);\n  return matchKey || (name?.split(' ')[0] || name);\n}\n\nfunction getServiceDetails(serviceInfo, serviceName, expertName){\n  const dict = serviceInfo?.[serviceName] || {};\n  if (dict[expertName]) return dict[expertName];\n  const norm = normalizeExpertName(expertName);\n  const key = Object.keys(dict).find(k => normalizeExpertName(k) === norm);\n  if (key) return dict[key];\n  \n  if (SERVICE_CAPABILITIES[serviceName]) {\n    const canDo = SERVICE_CAPABILITIES[serviceName].some(ex => normalizeExpertName(ex) === norm);\n    if (canDo && Object.keys(dict).length > 0) {\n      const fallbackExpert = Object.keys(dict)[0];\n      console.warn(`⚠️ ${serviceName} - ${expertName} bilgisi eksik, ${fallbackExpert} bilgisi kullanılıyor`);\n      return dict[fallbackExpert];\n    }\n  }\n  \n  return null;\n}\n\nfunction conflictsWithScheduled(dateStr, timeSlot, scheduled) {\n  const s = timeToMinutes(timeSlot.start);\n  const e = timeToMinutes(timeSlot.end);\n  return scheduled.some(a => a.date === dateStr && s < timeToMinutes(a.end) && e > timeToMinutes(a.start));\n}\n\nfunction hintMinFromTimeHint(timeHint) {\n  if (!timeHint) return null;\n  const map = { \"sabah\": 6*60, \"öğle\": 12*60+30, \"öğleden sonra\": 14*60, \"akşam\": 18*60, \"18:00+\": 18*60 };\n  if (map[timeHint] != null) return map[timeHint];\n  if (String(timeHint).includes(':')) return timeToMinutes(timeHint);\n  return null;\n}\n\n// ============================================\n// BÖLÜM 2: STATİK KONFIGÜRASYON (Mevcut - Değişiklik Yok)\n// ============================================\n\nconst MIN_NEAR_DUP_GAP_MIN = 10;\nconst MIN_PRESENT_GAP_MIN = 60;\nconst MIN_PARALLEL_OVERLAP_MIN = 15;  // ✅ YENİ: Minimum çakışma süresi\n\nconst TIME_WINDOWS = {\n  MORNING: { start: 10*60, end: 13*60 },\n  NOON: { start: 13*60, end: 16*60 },\n  AFTERNOON: { start: 16*60, end: 18*60 },\n  EVENING: { start: 18*60, end: 20*60 }\n};\n\nfunction getTimeWindow(timeStr) {\n  const mins = timeToMinutes(timeStr);\n  if (mins >= TIME_WINDOWS.MORNING.start && mins < TIME_WINDOWS.MORNING.end) return \"morning\";\n  if (mins >= TIME_WINDOWS.NOON.start && mins < TIME_WINDOWS.NOON.end) return \"noon\";\n  if (mins >= TIME_WINDOWS.AFTERNOON.start && mins < TIME_WINDOWS.AFTERNOON.end) return \"afternoon\";\n  if (mins >= TIME_WINDOWS.EVENING.start && mins < TIME_WINDOWS.EVENING.end) return \"evening\";\n  return \"other\";\n}\n\nfunction getTimeWindowName(timeStr) {\n  const mins = timeToMinutes(timeStr);\n  if (mins >= TIME_WINDOWS.MORNING.start && mins < TIME_WINDOWS.MORNING.end) return \"morning\";\n  if (mins >= TIME_WINDOWS.NOON.start && mins < TIME_WINDOWS.NOON.end) return \"noon\";\n  if (mins >= TIME_WINDOWS.AFTERNOON.start && mins < TIME_WINDOWS.AFTERNOON.end) return \"afternoon\";\n  if (mins >= TIME_WINDOWS.EVENING.start) return \"evening\";\n  return \"morning\";\n}\n\nfunction isTimeGapSufficient(time1, time2, minGap = MIN_PRESENT_GAP_MIN) {\n  return Math.abs(timeToMinutes(time1) - timeToMinutes(time2)) >= minGap;\n}\n\nconst EXPERT_RULES = {\n  \"Pınar\": {\n    fixed_slots: [10, 12, 14, 16, 18],  // Varsayılan (geriye dönük uyumluluk)\n    service_slots: {\n      \"Protez Tırnak\": [\"10:00\", \"12:00\", \"14:00\", \"16:00\", \"18:00\"],\n      \"Kalıcı Oje\": [\"10:00\", \"10:30\", \"12:00\", \"12:30\", \"14:00\", \"14:30\", \"16:00\", \"16:30\", \"18:00\", \"18:30\"]\n    },\n    services: [\n      \"Protez Tırnak\", \"Medikal Manikür\", \"Islak Manikür\",\n      \"Kalıcı Oje\", \"Kalıcı Oje + Jel Güçlendirme\",\n      \"Tırnak Çıkarma\", \"Kalıcı Oje Çıkarma\"\n    ]\n  },\n  \"Ceren\": {\n    fixed_slots: [10, 13, 16],  // Varsayılan (geriye dönük uyumluluk)\n    service_slots: {\n      \"Protez Tırnak\": [\"11:00\", \"14:00\", \"17:00\"],\n      \"Kalıcı Oje\": [\"11:00\", \"12:00\", \"14:00\", \"15:00\", \"17:00\", \"18:00\"]\n    },\n    services: [\n      \"Protez Tırnak\", \"Medikal Manikür\",\n      \"Kalıcı Oje\", \"Kalıcı Oje + Jel Güçlendirme\",\n      \"Tırnak Çıkarma\", \"Kalıcı Oje Çıkarma\"\n    ]\n  },\n  \"Sevcan\": {\n    fixed_slots: null,\n    service_slots: {},\n    services: [\n      \"Islak Manikür\", \"Lazer Epilasyon\", \"Ağda\",\n      \"Kaş Alımı\", \"Kaş Lifting\", \"Kaş Laminasyon\",\n      \"Manikür\", \"Pedikür\", \"Ayak Kalıcı Oje\",\n      \"G5 Masaj Göbek\", \"G5 Masaj Bacak\", \"G5 Masaj Sırt\",\n      \"Cilt Bakımı\", \"Kalıcı Oje Çıkarma\"\n    ]\n  }\n};\n\nconst GAP_FILLABLE_SERVICES = {\n  \"Medikal Manikür\": { min_duration: 20, max_duration: 45 },\n  \"Islak Manikür\": { min_duration: 30, max_duration: 45 },\n  \"Kalıcı Oje Çıkarma\": { min_duration: 10, max_duration: 20 },\n  \"Tırnak Çıkarma\": { min_duration: 10, max_duration: 20 },\n  \"Kalıcı Oje\": { min_duration: 20, max_duration: 45 },\n  \"Kalıcı Oje + Jel Güçlendirme\": { min_duration: 30, max_duration: 60 }\n};\n\nfunction isGapFillableService(serviceName) {\n  const normalized = normalizeServiceName(serviceName);\n  return GAP_FILLABLE_SERVICES.hasOwnProperty(normalized);\n}\n\nconst SERVICE_CAPABILITIES = {\n  \"Protez Tırnak\": [\"Pınar\", \"Ceren\"],\n  \"Kalıcı Oje\": [\"Pınar\", \"Ceren\"],\n  \"Kalıcı Oje + Jel Güçlendirme\": [\"Pınar\", \"Ceren\"],\n  \"Islak Manikür\": [\"Pınar\", \"Sevcan\"],\n  \"Medikal Manikür\": [\"Pınar\", \"Ceren\"],\n  \"Tırnak Çıkarma\": [\"Pınar\", \"Ceren\", \"Sevcan\"],\n  \"Kalıcı Oje Çıkarma\": [\"Pınar\", \"Ceren\", \"Sevcan\"],\n  \"Kaş Alımı\": [\"Sevcan\"],\n  \"Kaş Laminasyon\": [\"Sevcan\"],\n  \"Kaş + Bıyık\": [\"Sevcan\"],\n  \"Lifting\": [\"Sevcan\"],\n  \"Cilt Bakımı\": [\"Sevcan\"],\n  \"G5 Masaj Göbek\": [\"Sevcan\"],\n  \"G5 Masaj Bacak\": [\"Sevcan\"],\n  \"G5 Masaj Sırt\": [\"Sevcan\"],\n  \"Lazer Tüm Bacak\": [\"Sevcan\"],\n  \"Lazer Yarım Bacak\": [\"Sevcan\"],\n  \"Lazer Tüm Kol\": [\"Sevcan\"],\n  \"Lazer Yarım Kol\": [\"Sevcan\"],\n  \"Lazer Genital\": [\"Sevcan\"],\n  \"Lazer Koltuk Altı\": [\"Sevcan\"],\n  \"Lazer Tüm Sırt\": [\"Sevcan\"],\n  \"Lazer Tüm Göbek Göğüs\": [\"Sevcan\"],\n  \"Lazer Popo\": [\"Sevcan\"],\n  \"Lazer Yüz Bıyık\": [\"Sevcan\"],\n  \"Lazer Alın Hariç Yüz\": [\"Sevcan\"],\n  \"Lazer Komple Yüz\": [\"Sevcan\"],\n  \"Ağda Tüm Bacak\": [\"Sevcan\"],\n  \"Ağda Tüm Kol\": [\"Sevcan\"],\n  \"Ağda Genital\": [\"Sevcan\"],\n  \"Ağda Koltuk Altı\": [\"Sevcan\"],\n  \"Ağda Göbek\": [\"Sevcan\"],\n  \"Ağda Sırt\": [\"Sevcan\"],\n  \"Ağda Popo\": [\"Sevcan\"],\n  \"Ağda Yüz Komple\": [\"Sevcan\"],\n  \"Ağda Bıyık\": [\"Sevcan\"],\n  \"Ağda Alın Hariç Yüz\": [\"Sevcan\"],\n  \"Pedikür\": [\"Sevcan\"],\n  \"Medikal Pedikür\": [\"Sevcan\"],\n  \"Islak Pedikür\": [\"Sevcan\"],\n  \"Ayak Kalıcı Oje\": [\"Sevcan\"]\n};\n\nconst SERVICE_CATEGORIES = [\n  { match: n => n.startsWith(\"Lazer\"), experts: [\"Sevcan\"] },\n  { match: n => n.startsWith(\"Ağda\"), experts: [\"Sevcan\"] },\n  { match: n => n.startsWith(\"Kaş\"), experts: [\"Sevcan\"] },\n  { match: n => n.startsWith(\"G5 Masaj\"), experts: [\"Sevcan\"] },\n  { match: n => n === \"Cilt Bakımı\", experts: [\"Sevcan\"] },\n  { match: n => n.includes(\"Pedikür\"), experts: [\"Sevcan\"] },\n  { match: n => n === \"Manikür\", experts: [\"Sevcan\"] }\n];\n\nfunction categoryExperts(serviceName){\n  const hit = SERVICE_CATEGORIES.find(c => c.match(serviceName));\n  return hit ? hit.experts : [];\n}\n\nconst WORKING_HOURS = { start: \"10:00\", end: \"20:00\", closed_day: 0 };\n\nfunction isNailAnchor(serviceName){\n  const s = normalizeServiceName(serviceName);\n  return [\"Protez Tırnak\", \"Kalıcı Oje\", \"Kalıcı Oje + Jel Güçlendirme\"].includes(s);\n}\n\nfunction eligibleExpertsForService(serviceName, serviceInfo) {\n  const s = normalizeServiceName(serviceName);\n  const listedRaw = Object.keys(serviceInfo?.[s] || {});\n  \n  const fromServiceInfo = listedRaw.length ? [...new Set(listedRaw.map(canonicalExpert))] : [];\n  const fromCapabilities = SERVICE_CAPABILITIES[s] ? SERVICE_CAPABILITIES[s].map(canonicalExpert) : [];\n  \n  const combined = [...new Set([...fromServiceInfo, ...fromCapabilities])];\n  \n  if (combined.length) return combined;\n  \n  const cat = categoryExperts(s);\n  if (cat.length) return cat.map(canonicalExpert);\n  \n  return Object.keys(EXPERT_RULES).filter(ex => (EXPERT_RULES[ex].services || []).includes(s)).map(canonicalExpert);\n}\n\nfunction isServiceAllowedForExpert(serviceName, expertName, serviceInfo){\n  const s = normalizeServiceName(serviceName);\n  if (getServiceDetails(serviceInfo, s, expertName)) return true;\n  if (SERVICE_CAPABILITIES[s]) {\n    return SERVICE_CAPABILITIES[s].some(ex => normalizeExpertName(ex) === normalizeExpertName(expertName));\n  }\n  if (categoryExperts(s).some(ex => normalizeExpertName(ex) === normalizeExpertName(expertName))) return true;\n  return (EXPERT_RULES[canonicalExpert(expertName)]?.services || []).includes(s);\n}\n\n// ============================================\n// BÖLÜM 2B: ✨ YENİ - GRUP RANDEVU FONKSİYONLARI\n// ============================================\n\nfunction isGroupBooking(services) {\n  const uniquePersons = [...new Set(services.map(s => s.for_person).filter(Boolean))];\n  return uniquePersons.length > 1;\n}\n\nfunction detectSameExpert(services) {\n  // Sadece expert_preference belirtilmiş olanları al\n  const experts = services\n    .map(s => s.expert_preference)\n    .filter(Boolean)\n    .map(canonicalExpert);\n  \n  if (experts.length === 0) return { sameExpert: false };\n  \n  const uniqueExperts = [...new Set(experts)];\n  \n  // Tüm hizmetler aynı uzmandan mı?\n  if (uniqueExperts.length === 1 && experts.length === services.length) {\n    return {\n      sameExpert: true,\n      expert: uniqueExperts[0],\n      forceSequential: true  // Paralel OLAMAZ\n    };\n  }\n  \n  return { sameExpert: false };\n}\n\nfunction calculateOverlap(slot1, slot2) {\n  const start1 = timeToMinutes(slot1.start);\n  const end1 = timeToMinutes(slot1.end);\n  const start2 = timeToMinutes(slot2.start);\n  const end2 = timeToMinutes(slot2.end);\n  \n  return Math.max(0, Math.min(end1, end2) - Math.max(start1, start2));\n}\n\nfunction getArrangement(appointments) {\n  if (appointments.length < 2) return \"single\";\n  \n  // İki randevu arasındaki çakışmayı kontrol et\n  for (let i = 0; i < appointments.length - 1; i++) {\n    for (let j = i + 1; j < appointments.length; j++) {\n      const apt1 = appointments[i];\n      const apt2 = appointments[j];\n      \n      // Aynı gün değilse sequential\n      if (apt1.date !== apt2.date) continue;\n      \n      const overlap = calculateOverlap(apt1, apt2);\n      \n      // 15+ dk çakışma varsa parallel\n      if (overlap >= MIN_PARALLEL_OVERLAP_MIN) {\n        return \"parallel\";\n      }\n    }\n  }\n  \n  return \"sequential\";\n}\n\nfunction calculateTotalDuration(appointments, arrangement) {\n  if (appointments.length === 0) return 0;\n  \n  if (arrangement === \"parallel\") {\n    // Paralel: En erken başlama - en geç bitiş\n    const allSameDays = appointments.every(a => a.date === appointments[0].date);\n    \n    if (allSameDays) {\n      const earliestStart = Math.min(...appointments.map(a => timeToMinutes(a.start)));\n      const latestEnd = Math.max(...appointments.map(a => timeToMinutes(a.end)));\n      return latestEnd - earliestStart;\n    }\n  }\n  \n  // Sequential: Toplam süre\n  return appointments.reduce((sum, a) => sum + (a.duration || 0), 0);\n}\n\n// ============================================\n// BÖLÜM 3-7: TARİH, İZİN, ÇAKIŞMA, GAP, UZMAN, MÜSAİTLİK\n// (Mevcut kod - Değişiklik Yok)\n// ============================================\n\nfunction parseDateInfo(dateInfo) {\n  let dates = [];\n  if (dateInfo.type === \"specific\") {\n    dates = [parseTurkishDate(dateInfo.value)];\n  } else if (dateInfo.type === \"range\") {\n    const [start, end] = dateInfo.search_range.split(' to ');\n    const startDate = parseTurkishDate(start);\n    const endDate = parseTurkishDate(end);\n    let current = new Date(startDate);\n    while (current <= endDate) { dates.push(new Date(current)); current.setDate(current.getDate() + 1); }\n  } else if (dateInfo.type === \"specific_days\") {\n    const [start, end] = dateInfo.search_range.split(' to ');\n    const startDate = parseTurkishDate(start);\n    const endDate = parseTurkishDate(end);\n    const dayMapping = { \"Pazartesi\":1, \"Salı\":2, \"Çarşamba\":3, \"Perşembe\":4, \"Cuma\":5, \"Cumartesi\":6 };\n    const targetDays = (dateInfo.days || []).map(d => dayMapping[d]);\n    let current = new Date(startDate);\n    while (current <= endDate) { if (targetDays.includes(current.getDay())) dates.push(new Date(current)); current.setDate(current.getDate() + 1); }\n  } else if (dateInfo.type === \"urgent\") {\n    dates = [parseTurkishDate(dateInfo.value)];\n  }\n  return dates;\n}\n\nfunction isExpertOnLeave(expertName, checkDate, timeSlot, staffLeaves) {\n  const checkDateObj = typeof checkDate === 'string' ? parseTurkishDate(checkDate) : checkDate;\n  const normalizedExpert = normalizeExpertName(expertName);\n\n  for (const leave of staffLeaves || []) {\n    if (!leave || !leave.uzman_adi) continue;\n    if (normalizeExpertName(leave.uzman_adi) !== normalizedExpert) continue;\n    const leaveStart = parseTurkishDate(leave.baslangic_tarihi);\n    const leaveEnd = parseTurkishDate(leave.bitis_tarihi);\n    if (checkDateObj < leaveStart || checkDateObj > leaveEnd) continue;\n    if (leave.durum === \"Tam Gün\") return true;\n\n    if (leave.durum === \"Yarım Gün\" && leave.baslangic_saat && leave.bitis_saat && timeSlot) {\n      const leaveStartMin = timeToMinutes(leave.baslangic_saat);\n      const leaveEndMin = timeToMinutes(leave.bitis_saat);\n      const checkStartMin = timeToMinutes(timeSlot.start);\n      const checkEndMin = timeToMinutes(timeSlot.end);\n      if (checkStartMin < leaveEndMin && checkEndMin > leaveStartMin) return true;\n    }\n  }\n  return false;\n}\n\nfunction hasAppointmentConflict(date, expert, timeSlot, existingAppointments) {\n  const checkDateStr = typeof date === 'string' ? date : formatTurkishDate(date);\n  const checkStartMin = timeToMinutes(timeSlot.start);\n  const checkEndMin = timeToMinutes(timeSlot.end);\n  const normalizedExpert = normalizeExpertName(expert);\n\n  for (const apt of existingAppointments || []) {\n    if (!apt.uzman_adi) continue;\n    if (normalizeExpertName(apt.uzman_adi) !== normalizedExpert) continue;\n    if (apt.tarih !== checkDateStr) continue;\n    if (apt.baslangic_saat && apt.bitis_saat) {\n      const aptStartMin = timeToMinutes(apt.baslangic_saat);\n      const aptEndMin = timeToMinutes(apt.bitis_saat);\n      if (checkStartMin < aptEndMin && checkEndMin > aptStartMin) return true;\n    }\n  }\n  return false;\n}\n\nfunction findGapSlots(dateStr, expert, serviceDuration, existingAppointments, staffLeaves, filters=null, currentTime=null) {\n  const gaps = [];\n  const normalizedExpert = normalizeExpertName(expert);\n  \n  const expertApts = (existingAppointments || [])\n    .filter(a => a.uzman_adi && normalizeExpertName(a.uzman_adi) === normalizedExpert && a.tarih === dateStr)\n    .filter(a => a.baslangic_saat && a.bitis_saat)\n    .sort((a, b) => timeToMinutes(a.baslangic_saat) - timeToMinutes(b.baslangic_saat));\n  \n  if (expertApts.length === 0) return gaps;\n  \n  const dateObj = parseTurkishDate(dateStr);\n  const today = new Date();\n  const isToday = dateObj.getDate() === today.getDate() && \n                  dateObj.getMonth() === today.getMonth() && \n                  dateObj.getFullYear() === today.getFullYear();\n  \n  const minStartTimeMinutes = (isToday && currentTime) ? timeToMinutes(currentTime) : 0;\n  \n  for (let i = 0; i < expertApts.length - 1; i++) {\n    const current = expertApts[i];\n    const next = expertApts[i + 1];\n    \n    const gapStartMin = timeToMinutes(current.bitis_saat);\n    const gapEndMin = timeToMinutes(next.baslangic_saat);\n    const gapSize = gapEndMin - gapStartMin;\n    \n    if (isToday && gapStartMin <= minStartTimeMinutes) continue;\n    \n    if (gapSize >= serviceDuration) {\n      const slotStart = current.bitis_saat;\n      const slotEnd = addMinutes(slotStart, serviceDuration);\n      const timeSlot = { start: slotStart, end: slotEnd };\n      \n      if (timeToMinutes(slotEnd) > timeToMinutes(WORKING_HOURS.end)) continue;\n      if (filters && !withinTimeWindow(timeSlot, filters)) continue;\n      if (isExpertOnLeave(expert, dateStr, timeSlot, staffLeaves)) continue;\n      \n      gaps.push(timeSlot);\n    }\n  }\n  \n  return gaps;\n}\n\nfunction assignExpert(service, serviceInfo) {\n  const sname = normalizeServiceName(service.name);\n  if (isNailAnchor(sname) && service.expert_preference) {\n    return canonicalExpert(service.expert_preference);\n  }\n  const availableExperts = eligibleExpertsForService(sname, serviceInfo)\n    .filter(ex => getServiceDetails(serviceInfo, sname, ex));\n  if (availableExperts.length === 0) return null;\n  return availableExperts[0];\n}\n\nfunction withinTimeWindow(slot, filters) {\n  const fw = filters?.time_window;\n  const strict = !!filters?.time_window_strict;\n  if (!fw || !fw.start || !fw.end || !strict) return true;\n  const s = timeToMinutes(slot.start);\n  const e = timeToMinutes(slot.end);\n  const ws = timeToMinutes(fw.start);\n  const we = timeToMinutes(fw.end);\n  return s >= ws && e <= we;\n}\n\nfunction datePassesBounds(dateStr, filters) {\n  if (!filters) return true;\n  const d = parseTurkishDate(dateStr);\n  if (filters.earliest_date && d < parseTurkishDate(filters.earliest_date)) return false;\n  if (filters.latest_date && d > parseTurkishDate(filters.latest_date)) return false;\n  return true;\n}\n\nfunction findAvailableSlots(date, expert, service, existingAppointments, staffLeaves, serviceInfo, filters=null, currentTime=null) {\n  const dateStr = typeof date === 'string' ? date : formatTurkishDate(date);\n  const dateObj = typeof date === 'string' ? parseTurkishDate(date) : date;\n  if (dateObj.getDay() === WORKING_HOURS.closed_day) return [];\n  if (!datePassesBounds(dateStr, filters)) return [];\n\n  const expertRules = EXPERT_RULES[canonicalExpert(expert)];\n  if (!expertRules) return [];\n\n  const sname = normalizeServiceName(service.name);\n  if (!isServiceAllowedForExpert(sname, expert, serviceInfo)) return [];\n  const serviceDetails = getServiceDetails(serviceInfo, sname, expert);\n  if (!serviceDetails) return [];\n\n  const duration = parseInt(serviceDetails.sure);\n  const availableSlots = [];\n\n  const today = new Date();\n  const isToday = dateObj.getDate() === today.getDate() && \n                  dateObj.getMonth() === today.getMonth() && \n                  dateObj.getFullYear() === today.getFullYear();\n  \n  const minStartTimeMinutes = (isToday && currentTime) ? timeToMinutes(currentTime) : 0;\n\n  // Servise özel slot'ları kontrol et\n  let slotsToUse = null;\n  if (expertRules.service_slots && expertRules.service_slots[sname]) {\n    slotsToUse = expertRules.service_slots[sname];  // [\"10:00\", \"12:00\", ...] formatında\n  } else if (expertRules.fixed_slots) {\n    slotsToUse = expertRules.fixed_slots.map(h => `${String(h).padStart(2, '0')}:00`);  // [10, 12, ...] -> [\"10:00\", \"12:00\", ...]\n  }\n\n  if (slotsToUse && slotsToUse.length > 0) {\n    for (const startTime of slotsToUse) {\n      if (isToday && timeToMinutes(startTime) <= minStartTimeMinutes) continue;\n\n      const endTime = addMinutes(startTime, duration);\n      if (timeToMinutes(endTime) > timeToMinutes(WORKING_HOURS.end)) continue;\n\n      const timeSlot = { start: startTime, end: endTime };\n      if (!withinTimeWindow(timeSlot, filters)) continue;\n      if (isExpertOnLeave(expert, dateStr, timeSlot, staffLeaves)) continue;\n      if (hasAppointmentConflict(dateStr, expert, timeSlot, existingAppointments)) continue;\n      availableSlots.push(timeSlot);\n    }\n    \n    if (isGapFillableService(sname)) {\n      const gapSlots = findGapSlots(dateStr, expert, duration, existingAppointments, staffLeaves, filters, currentTime);\n      \n      for (const gap of gapSlots) {\n        const isDuplicate = availableSlots.some(slot => \n          timeToMinutes(slot.start) === timeToMinutes(gap.start) && \n          timeToMinutes(slot.end) === timeToMinutes(gap.end)\n        );\n        \n        if (!isDuplicate) {\n          availableSlots.push(gap);\n        }\n      }\n    }\n  } else {\n    let currentMin = timeToMinutes(WORKING_HOURS.start);\n    const endMin = timeToMinutes(WORKING_HOURS.end);\n    const STEP = 5;\n    \n    while (currentMin < endMin) {\n      const startTime = minutesToTime(currentMin);\n      \n      if (isToday && currentMin <= minStartTimeMinutes) {\n        currentMin += STEP;\n        continue;\n      }\n      \n      const endTime = addMinutes(startTime, duration);\n      if (timeToMinutes(endTime) > endMin) break;\n\n      const timeSlot = { start: startTime, end: endTime };\n      if (!withinTimeWindow(timeSlot, filters)) { currentMin += STEP; continue; }\n      if (isExpertOnLeave(expert, dateStr, timeSlot, staffLeaves)) { currentMin += STEP; continue; }\n      if (hasAppointmentConflict(dateStr, expert, timeSlot, existingAppointments)) { currentMin += STEP; continue; }\n      availableSlots.push(timeSlot);\n      currentMin += STEP;\n    }\n  }\n  \n  availableSlots.sort((a, b) => timeToMinutes(a.start) - timeToMinutes(b.start));\n  \n  return availableSlots;\n}\n\nfunction findSlotsEndingAt(dateStr, expert, serviceName, existingAppointments, staffLeaves, serviceInfo, filters, targetEndTime, currentTime=null) {\n  const slots = findAvailableSlots(dateStr, expert, { name: serviceName }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime);\n  return slots.filter(sl => timeToMinutes(sl.end) === timeToMinutes(targetEndTime));\n}\n\n// ============================================\n// BÖLÜM 8: CONSTRAINTS NORMALİZASYONU (Güncellenmiş)\n// ============================================\n\nfunction buildEffectiveConstraints(dateInfo, constraints, services) {\n  const eff = { ...(constraints || {}) };\n  \n  // Grup randevu tespiti\n  const isGroup = isGroupBooking(services);\n  const sameExpertInfo = detectSameExpert(services);\n\n  eff.same_day_required = (typeof eff.same_day_required !== 'undefined') ? eff.same_day_required : (isGroup || dateInfo?.type === 'specific');\n  eff.chain_adjacent_only = sameExpertInfo.forceSequential ? true : (typeof eff.chain_adjacent_only !== 'undefined') ? eff.chain_adjacent_only : true;\n\n  eff.filters = eff.filters || {};\n  eff.filters.nail_expert_strict = !!eff.filters.nail_expert_strict;\n  eff.filters.time_window_strict  = !!eff.filters.time_window_strict;\n\n  if (!eff.anchor_window) {\n    eff.anchor_window = { mode: 'reference', before_buffer_min: 0, after_buffer_min: 0 };\n  }\n\n  eff.service_groups = (constraints?.service_groups || []).map(g => ({\n    services: (g.services || []).map(normalizeServiceName),\n    same_day: !!g.same_day,\n    chain_adjacent_only: (typeof g.chain_adjacent_only !== 'undefined') ? g.chain_adjacent_only : true,\n    time_hint: g.time_hint || null\n  }));\n\n  const hasTimeWindow = !!(eff.filters.time_window && eff.filters.time_window.start && eff.filters.time_window.end);\n  const hintedMin = hintMinFromTimeHint(dateInfo?.time_hint);\n\n  if (!dateInfo.target_time && hasTimeWindow) {\n    dateInfo.target_time = eff.filters.time_window.start;\n  } else if (!dateInfo.target_time && hintedMin != null) {\n    dateInfo.target_time = minutesToTime(hintedMin);\n  }\n  \n  // ✅ Grup bilgisi ekle\n  eff.is_group = isGroup;\n  eff.same_expert_info = sameExpertInfo;\n\n  return eff;\n}\n\n// ============================================\n// BÖLÜM 9: GRUP PLANLAMA (Mevcut - Değişiklik Yok)\n// ============================================\n\nfunction scheduleServiceGroupOnSameDay(group, allDates, existingAppointments, staffLeaves, serviceInfo, scheduledSoFar, filters, currentTime=null) {\n  if (!group?.services || group.services.length < 2) return null;\n  const seq = [...group.services];\n\n  for (const tryDate of allDates) {\n    if (tryDate.getDay() === WORKING_HOURS.closed_day) continue;\n    const dateStr = formatTurkishDate(tryDate);\n    if (!datePassesBounds(dateStr, { ...filters })) continue;\n\n    const minStart = hintMinFromTimeHint(group.time_hint);\n\n    const s1 = seq[0];\n    const e1Candidates = eligibleExpertsForService(s1, serviceInfo).filter(ex => getServiceDetails(serviceInfo, s1, ex));\n    for (const e1 of e1Candidates) {\n      const s1Slots = findAvailableSlots(dateStr, e1, { name: s1 }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime)\n        .filter(sl => (minStart == null) ? true : timeToMinutes(sl.start) >= minStart)\n        .filter(sl => !conflictsWithScheduled(dateStr, sl, scheduledSoFar));\n\n      for (const sl1 of s1Slots) {\n        const s2 = seq[1];\n        const e2Candidates = eligibleExpertsForService(s2, serviceInfo).filter(ex => getServiceDetails(serviceInfo, s2, ex));\n        for (const e2 of e2Candidates) {\n          const s2Slots = findAvailableSlots(dateStr, e2, { name: s2 }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime)\n            .filter(sl => !conflictsWithScheduled(dateStr, sl, scheduledSoFar));\n          const sl2 = s2Slots.find(sl => timeToMinutes(sl.start) === timeToMinutes(sl1.end));\n          if (!sl2) continue;\n\n          if (isExpertOnLeave(e1, dateStr, sl1, staffLeaves) || hasAppointmentConflict(dateStr, e1, sl1, existingAppointments)) continue;\n          if (isExpertOnLeave(e2, dateStr, sl2, staffLeaves) || hasAppointmentConflict(dateStr, e2, sl2, existingAppointments)) continue;\n\n          const det1 = getServiceDetails(serviceInfo, s1, e1);\n          const det2 = getServiceDetails(serviceInfo, s2, e2);\n          if (!det1 || !det2) continue;\n\n          return [\n            { date: dateStr, service: s1, expert: canonicalExpert(e1), start: sl1.start, end: sl1.end,\n              price: parseInt(det1.fiyat), duration: parseInt(det1.sure) },\n            { date: dateStr, service: s2, expert: canonicalExpert(e2), start: sl2.start, end: sl2.end,\n              price: parseInt(det2.fiyat), duration: parseInt(det2.sure) },\n          ];\n        }\n      }\n    }\n  }\n  return null;\n}\n\n// ============================================\n// BÖLÜM 10: ✨ TÜM İŞLEMLERİ YERLEŞTİR (GRUP DESTEĞİ EKLENDİ)\n// ============================================\n\nfunction tryScheduleAllServices(referenceSlot, remainingServices, dateInfo, existingAppointments, staffLeaves, serviceInfo, constraints, currentTime=null) {\n  const scheduled = [referenceSlot];\n  let currentDate = typeof referenceSlot.date === 'string' ? parseTurkishDate(referenceSlot.date) : referenceSlot.date;\n  let currentTimeSlot = referenceSlot.end;\n  const missingServices = [];\n\n  const allDates = parseDateInfo(dateInfo);\n  const filters = constraints?.filters || {};\n\n  const strictSameDay = constraints?.same_day_required === true;\n  const strictChainAdjacent = constraints?.chain_adjacent_only !== false;\n  const isGroup = constraints?.is_group || false;\n  const sameExpertInfo = constraints?.same_expert_info || { sameExpert: false };\n\n  // ✅ GRUP RANDEVU MANTIK\n  if (isGroup && remainingServices.length > 0) {\n    const dateStr = referenceSlot.date;\n\n    // Paralel veya arka arkaya yerleştirme\n    for (const service of remainingServices) {\n      const sname = normalizeServiceName(service.name);\n\n      // ✅ FİX: Aynı servisi farklı kişiler için ayırt et\n      if (scheduled.some(a => a.service === sname && a.for_person === service.for_person)) continue;\n\n      let eligible = eligibleExpertsForService(sname, serviceInfo).filter(ex => getServiceDetails(serviceInfo, sname, ex));\n      if (eligible.length === 0) return null;  // Grup = hepsi veya hiçbiri\n\n      // ✅ IMPROVED: Tercih edilen uzmanı önceliklendir (ama diğerlerini de dahil et - kullanıcı deneyimi)\n      if (sameExpertInfo.sameExpert && sameExpertInfo.expert) {\n        const preferredExpert = sameExpertInfo.expert;\n        const normalized = normalizeExpertName(preferredExpert);\n        // Tercih edilen uzmanı başa al\n        eligible = [\n          ...eligible.filter(ex => normalizeExpertName(ex) === normalized),\n          ...eligible.filter(ex => normalizeExpertName(ex) !== normalized)\n        ];\n      }\n\n      let placed = false;\n\n      // 1. PARALEL DENEME (Aynı uzman değilse)\n      if (!sameExpertInfo.sameExpert) {\n        for (const ex of eligible) {\n          // Referans slot ile çakışan slotlar bul\n          const allSlots = findAvailableSlots(dateStr, ex, { name: sname }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime);\n\n          for (const slot of allSlots) {\n            const overlap = calculateOverlap(referenceSlot, slot);\n\n            // 15+ dk çakışma var mı?\n            if (overlap >= MIN_PARALLEL_OVERLAP_MIN) {\n              const onLeave = isExpertOnLeave(ex, dateStr, slot, staffLeaves);\n              const hasConflict = hasAppointmentConflict(dateStr, ex, slot, existingAppointments);\n\n              // ✅ FİX: Aynı uzman çakışan slotta olamaz\n              const conflictsScheduled = scheduled.some(s => {\n                if (s.date !== dateStr) return false;\n                // Aynı uzman için zaman çakışması kontrolü\n                if (canonicalExpert(ex) === s.expert) {\n                  const sStart = timeToMinutes(s.start);\n                  const sEnd = timeToMinutes(s.end);\n                  const slotStart = timeToMinutes(slot.start);\n                  const slotEnd = timeToMinutes(slot.end);\n                  // Çakışma var mı? (slotStart < sEnd && slotEnd > sStart)\n                  return slotStart < sEnd && slotEnd > sStart;\n                }\n                // Farklı uzmanlar için çakışma kontrolü gerekli değil (paralel olabilir)\n                return false;\n              });\n\n              if (!onLeave && !hasConflict && !conflictsScheduled) {\n                const det = getServiceDetails(serviceInfo, sname, ex);\n                if (!det) continue;\n\n                scheduled.push({\n                  date: dateStr,\n                  expert: canonicalExpert(ex),\n                  service: sname,\n                  start: slot.start,\n                  end: slot.end,\n                  duration: parseInt(det.sure),\n                  price: parseInt(det.fiyat),\n                  for_person: service.for_person || null\n                });\n\n                placed = true;\n                break;\n              }\n            }\n          }\n          if (placed) break;\n        }\n      }\n      \n      // 2. ARKA ARKAYA DENEME (Paralel bulunamadıysa veya aynı uzman)\n      if (!placed) {\n        const targetStartMin = timeToMinutes(currentTimeSlot);\n        \n        for (const ex of eligible) {\n          const slots = findAvailableSlots(dateStr, ex, { name: sname }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime)\n            .filter(s => timeToMinutes(s.start) === targetStartMin)\n            .filter(s => !conflictsWithScheduled(dateStr, s, scheduled));\n\n          const slot = slots[0];\n          if (slot &&\n              !isExpertOnLeave(ex, dateStr, slot, staffLeaves) &&\n              !hasAppointmentConflict(dateStr, ex, slot, existingAppointments)) {\n            const det = getServiceDetails(serviceInfo, sname, ex);\n            if (!det) continue;\n\n            scheduled.push({\n              date: dateStr,\n              expert: canonicalExpert(ex),\n              service: sname,\n              start: slot.start,\n              end: slot.end,\n              duration: parseInt(det.sure),\n              price: parseInt(det.fiyat),\n              for_person: service.for_person || null\n            });\n\n            currentTimeSlot = slot.end;\n            placed = true;\n            break;\n          }\n        }\n      }\n      \n      if (!placed) return null;  // Grup = hepsi veya hiçbiri\n    }\n\n    const totalPrice = scheduled.reduce((sum, a) => sum + (a.price || 0), 0);\n    const arrangement = getArrangement(scheduled);\n    const totalDuration = calculateTotalDuration(scheduled, arrangement);\n\n    return {\n      complete: true,\n      appointments: scheduled,\n      missing_services: [],\n      total_price: totalPrice,\n      total_duration: totalDuration,\n      arrangement: arrangement\n    };\n  }\n\n  // ✅ TEK KİŞİ MANTIK (Mevcut kod devam ediyor...)\n  if (strictSameDay) {\n    const dateStr = referenceSlot.date;\n\n    const forwardFailed = [];\n    for (const service of remainingServices) {\n      const sname = normalizeServiceName(service.name);\n      if (scheduled.some(a => a.service === sname)) continue;\n\n      const eligible = eligibleExpertsForService(sname, serviceInfo).filter(ex => getServiceDetails(serviceInfo, sname, ex));\n      if (eligible.length === 0) { return null; }\n\n      let placed = false;\n      const targetStartMin = timeToMinutes(currentTimeSlot);\n\n      for (const ex of eligible) {\n        const slots = findAvailableSlots(dateStr, ex, { name: sname }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime)\n          .filter(s => timeToMinutes(s.start) === targetStartMin)\n          .filter(s => !conflictsWithScheduled(dateStr, s, scheduled));\n\n        const slot = slots[0];\n        if (slot &&\n            !isExpertOnLeave(ex, dateStr, slot, staffLeaves) &&\n            !hasAppointmentConflict(dateStr, ex, slot, existingAppointments)) {\n          const det = getServiceDetails(serviceInfo, sname, ex);\n          if (!det) continue;\n\n          scheduled.push({\n            date: dateStr,\n            expert: canonicalExpert(ex),\n            service: sname,\n            start: slot.start,\n            end: slot.end,\n            duration: parseInt(det.sure),\n            price: parseInt(det.fiyat),\n            for_person: service.for_person || null\n          });\n\n          currentTimeSlot = slot.end;\n          placed = true;\n          break;\n        }\n      }\n\n      if (!placed && !strictChainAdjacent) {\n        for (const ex of eligible) {\n          const slots = findAvailableSlots(dateStr, ex, { name: sname }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime)\n            .filter(s => timeToMinutes(s.start) >= targetStartMin)\n            .filter(s => !conflictsWithScheduled(dateStr, s, scheduled));\n\n          const slot = slots[0];\n          if (slot &&\n              !isExpertOnLeave(ex, dateStr, slot, staffLeaves) &&\n              !hasAppointmentConflict(dateStr, ex, slot, existingAppointments)) {\n            const det = getServiceDetails(serviceInfo, sname, ex);\n            if (!det) continue;\n\n            scheduled.push({\n              date: dateStr,\n              expert: canonicalExpert(ex),\n              service: sname,\n              start: slot.start,\n              end: slot.end,\n              duration: parseInt(det.sure),\n              price: parseInt(det.fiyat),\n              for_person: service.for_person || null\n            });\n\n            currentTimeSlot = slot.end;\n            placed = true;\n            break;\n          }\n        }\n      }\n\n      if (!placed) {\n        forwardFailed.push(service);\n      }\n    }\n\n    forwardFailed.sort((a,b) => {\n      const dur = (svc) => {\n        const sname = normalizeServiceName(svc.name);\n        const durs = eligibleExpertsForService(sname, serviceInfo)\n          .map(ex => parseInt(getServiceDetails(serviceInfo, sname, ex)?.sure || 0));\n        return Math.max(...durs, 0);\n      };\n      return dur(b) - dur(a);\n    });\n\n    let headStart = referenceSlot.start;\n\n    for (const service of forwardFailed) {\n      const sname = normalizeServiceName(service.name);\n      if (scheduled.some(a => a.service === sname)) continue;\n\n      const eligible = eligibleExpertsForService(sname, serviceInfo).filter(ex => getServiceDetails(serviceInfo, sname, ex));\n      if (eligible.length === 0) { return null; }\n\n      let placed = false;\n      for (const ex of eligible) {\n        const slots = findSlotsEndingAt(dateStr, ex, sname, existingAppointments, staffLeaves, serviceInfo, filters, headStart, currentTime)\n          .filter(s => !conflictsWithScheduled(dateStr, s, scheduled));\n        const slot = slots[0];\n\n        if (slot &&\n            !isExpertOnLeave(ex, dateStr, slot, staffLeaves) &&\n            !hasAppointmentConflict(dateStr, ex, slot, existingAppointments)) {\n          const det = getServiceDetails(serviceInfo, sname, ex);\n          if (!det) continue;\n\n          scheduled.unshift({\n            date: dateStr, expert: canonicalExpert(ex), service: sname,\n            start: slot.start, end: slot.end,\n            duration: parseInt(det.sure), price: parseInt(det.fiyat),\n            for_person: service.for_person || null\n          });\n          headStart = slot.start;\n          placed = true;\n          break;\n        }\n      }\n      if (!placed) return null;\n    }\n\n    const totalPrice = scheduled.reduce((sum, a) => sum + (a.price || 0), 0);\n    const arrangement = getArrangement(scheduled);\n    const totalDuration = calculateTotalDuration(scheduled, arrangement);\n\n    return {\n      complete: true,\n      appointments: scheduled,\n      missing_services: [],\n      total_price: totalPrice,\n      total_duration: totalDuration,\n      arrangement: arrangement\n    };\n  }\n\n  const flexChainAdjacent = constraints?.chain_adjacent_only !== false;\n  \n  for (const service of remainingServices) {\n    const sname = normalizeServiceName(service.name);\n    if (scheduled.some(a => a.service === sname)) continue;\n\n    const eligible = eligibleExpertsForService(sname, serviceInfo).filter(ex => getServiceDetails(serviceInfo, sname, ex));\n    if (eligible.length === 0) { \n      missingServices.push(sname); \n      continue; \n    }\n\n    let placed = false;\n\n    const dateStrSame = formatTurkishDate(currentDate);\n    const notBefore = timeToMinutes(currentTimeSlot);\n\n    for (const ex of eligible) {\n      const sameDaySlots = findAvailableSlots(dateStrSame, ex, { name: sname }, existingAppointments, staffLeaves, serviceInfo, constraints?.filters || {}, currentTime)\n        .filter(s => timeToMinutes(s.start) === notBefore)\n        .filter(s => !conflictsWithScheduled(dateStrSame, s, scheduled));\n      const slot = sameDaySlots[0];\n      if (slot &&\n          !isExpertOnLeave(ex, dateStrSame, slot, staffLeaves) &&\n          !hasAppointmentConflict(dateStrSame, ex, slot, existingAppointments)) {\n        const det = getServiceDetails(serviceInfo, sname, ex);\n        if (!det) continue;\n        scheduled.push({\n          date: dateStrSame, expert: canonicalExpert(ex), service: sname,\n          start: slot.start, end: slot.end, duration: parseInt(det.sure),\n          price: parseInt(det.fiyat),\n          for_person: service.for_person || null\n        });\n        currentTimeSlot = slot.end;\n        placed = true;\n        break;\n      }\n    }\n\n    if (!placed && !flexChainAdjacent) {\n      for (const ex of eligible) {\n        const sameDaySlots = findAvailableSlots(dateStrSame, ex, { name: sname }, existingAppointments, staffLeaves, serviceInfo, constraints?.filters || {}, currentTime)\n          .filter(s => timeToMinutes(s.start) >= notBefore)\n          .filter(s => !conflictsWithScheduled(dateStrSame, s, scheduled));\n        const slot = sameDaySlots[0];\n        if (slot &&\n            !isExpertOnLeave(ex, dateStrSame, slot, staffLeaves) &&\n            !hasAppointmentConflict(dateStrSame, ex, slot, existingAppointments)) {\n          const det = getServiceDetails(serviceInfo, sname, ex);\n          if (!det) continue;\n          scheduled.push({\n            date: dateStrSame, expert: canonicalExpert(ex), service: sname,\n            start: slot.start, end: slot.end, duration: parseInt(det.sure),\n            price: parseInt(det.fiyat),\n            for_person: service.for_person || null\n          });\n          currentTimeSlot = slot.end;\n          placed = true;\n          break;\n        }\n      }\n    }\n\n    if (placed) continue;\n\n    for (const tryDate of allDates) {\n      if (tryDate < currentDate) continue;\n      const dateStr = formatTurkishDate(tryDate);\n      if (!datePassesBounds(dateStr, constraints?.filters || {})) continue;\n\n      const startMin = timeToMinutes(WORKING_HOURS.start);\n\n      for (const ex of eligible) {\n        const slots = findAvailableSlots(dateStr, ex, { name: sname }, existingAppointments, staffLeaves, serviceInfo, constraints?.filters || {}, currentTime)\n          .filter(s => timeToMinutes(s.start) >= startMin)\n          .filter(s => !conflictsWithScheduled(dateStr, s, scheduled));\n        const slot = slots[0];\n        if (!slot) continue;\n\n        if (!isExpertOnLeave(ex, dateStr, slot, staffLeaves) &&\n            !hasAppointmentConflict(dateStr, ex, slot, existingAppointments)) {\n          const det = getServiceDetails(serviceInfo, sname, ex);\n          if (!det) continue;\n          scheduled.push({\n            date: dateStr, expert: canonicalExpert(ex), service: sname,\n            start: slot.start, end: slot.end, duration: parseInt(det.sure),\n            price: parseInt(det.fiyat),\n            for_person: service.for_person || null\n          });\n          currentDate = tryDate;\n          currentTimeSlot = slot.end;\n          placed = true;\n          break;\n        }\n      }\n      if (placed) break;\n    }\n\n    if (!placed) missingServices.push(sname);\n  }\n\n  const totalPrice = scheduled.reduce((sum, a) => sum + (a.price || 0), 0);\n  const arrangement = getArrangement(scheduled);\n  const totalDuration = calculateTotalDuration(scheduled, arrangement);\n\n  return {\n    complete: missingServices.length === 0,\n    appointments: scheduled,\n    missing_services: missingServices,\n    total_price: totalPrice,\n    total_duration: totalDuration,\n    arrangement: arrangement\n  };\n}\n\n// ============================================\n// BÖLÜM 11: ✨ PUANLAMA (PARALEL BONUS EKLENDİ)\n// ============================================\n\nfunction dayScore(deltaDays) {\n  if (deltaDays < 0) { const absDD = Math.abs(deltaDays); if (absDD === 1) return 12; if (absDD === 2) return 8; if (absDD <= 5) return 3; return 0; }\n  if (deltaDays === 0) return 25;\n  if (deltaDays === 1) return 20;\n  if (deltaDays === 2) return 15;\n  if (deltaDays === 3 || deltaDays === 4) return 10;\n  if (deltaDays >= 5 && deltaDays <= 7) return 6;\n  return 0;\n}\n\nfunction hourScore(absHourDiff) {\n  const map = {0:25,1:23,2:21,3:19,4:17,5:15,6:13,7:11,8:9,9:7,10:5};\n  return map[Math.min(10, absHourDiff)] || 0;\n}\n\nfunction expertScoreForCombo(combo, services) {\n  let totalScore = 0;\n  let matchCount = 0;\n  let totalPrefs = 0;\n\n  // Her randevu için tercih kontrolü yap\n  for (const apt of combo.appointments) {\n    const matchingService = services.find(s =>\n      normalizeServiceName(s.name) === apt.service &&\n      (s.for_person === apt.for_person || !s.for_person)\n    );\n\n    if (matchingService?.expert_preference) {\n      totalPrefs++;\n      const preferredExpert = canonicalExpert(matchingService.expert_preference);\n      if (apt.expert === preferredExpert) {\n        matchCount++;\n        totalScore += 15;  // Tercih edilen uzmana bonus\n      } else {\n        totalScore += 5;   // Tercih edilmeyen ama uygun uzman\n      }\n    } else {\n      totalScore += 10;  // Tercih yok, herhangi bir uzman\n    }\n  }\n\n  // Tüm tercihler tutturulduysa ekstra bonus\n  if (totalPrefs > 0 && matchCount === totalPrefs) {\n    totalScore += 10;\n  }\n\n  return totalScore;\n}\n\nfunction parallelScore(combo) {\n  // ✅ YENİ: Paralel randevu bonus puanı\n  return (combo.arrangement === \"parallel\") ? 10 : 0;\n}\n\nfunction computeScoresForAll(combos, dateInfo, services) {\n  const pmax = Math.max(...combos.map(c => c.total_price || 0), 1);\n  const pmin = Math.min(...combos.map(c => c.total_price || 0), 1);\n\n  let targetDate;\n  if (dateInfo.type === 'specific' || dateInfo.type === 'urgent') {\n    targetDate = parseTurkishDate(dateInfo.value);\n  } else if (dateInfo.type === 'range') {\n    const [start, end] = dateInfo.search_range.split(' to ');\n    targetDate = (dateInfo.preference === 'earliest') ? parseTurkishDate(start) : parseTurkishDate(end);\n  } else if (dateInfo.type === 'specific_days') {\n    targetDate = parseTurkishDate(dateInfo.search_range.split(' to ')[0]);\n  } else {\n    targetDate = parseTurkishDate(dateInfo.search_range.split(' to ')[0]);\n  }\n\n  const targetTimeMin = (dateInfo.target_time && String(dateInfo.target_time).includes(':'))\n    ? timeToMinutes(dateInfo.target_time)\n    : (dateInfo.time_hint && hintMinFromTimeHint(dateInfo.time_hint) != null ? hintMinFromTimeHint(dateInfo.time_hint) : null);\n\n  return combos.map(c => {\n    const first = c.appointments[0];\n    const firstDate = parseTurkishDate(first.date);\n    const dd = Math.round((firstDate - targetDate) / (1000*60*60*24));\n    const scoreDay = dayScore(dd);\n\n    let scoreHour = 0;\n    if (targetTimeMin != null) {\n      const hdiff = Math.abs(timeToMinutes(first.start) - targetTimeMin) / 60;\n      scoreHour = hourScore(Math.floor(hdiff));\n    }\n\n    const scoreExpert = expertScoreForCombo(c, services);\n    const scoreParallel = parallelScore(c);  // ✅ YENİ\n    \n    const priceRange = pmax - pmin;\n    const scoreValue = priceRange > 0 \n      ? Math.round(20 * (pmax - (c.total_price || 0)) / priceRange)\n      : 10;\n\n    const timeWindow = getTimeWindow(first.start);\n    \n    return { \n      ...c, \n      score: scoreDay + scoreHour + scoreExpert + scoreParallel + scoreValue,  // ✅ Paralel bonus eklendi\n      time_window: timeWindow\n    };\n  });\n}\n\n// ============================================\n// BÖLÜM 12-15: DEDUPE, ALTERNATİFLER, FOLLOW-UP\n// (Mevcut kod - Değişiklik Yok)\n// ============================================\n\nfunction serviceMultisetSignature(combo){\n  const parts = combo.appointments.map(a => `${a.service}|${a.expert}|${a.duration}`);\n  parts.sort();\n  return parts.join('||');\n}\n\nfunction comboWindowSignature(combo, bucket=MIN_NEAR_DUP_GAP_MIN){\n  const date = combo.appointments[0].date;\n  const startMin = timeToMinutes(combo.appointments[0].start);\n  const endMin   = timeToMinutes(combo.appointments[combo.appointments.length-1].end);\n  const rs = Math.round(startMin / bucket) * bucket;\n  const re = Math.round(endMin / bucket) * bucket;\n  return `${date}#${rs}-${re}`;\n}\n\nfunction areWindowsNear(ca, cb, gap=MIN_NEAR_DUP_GAP_MIN){\n  const aStart = timeToMinutes(ca.appointments[0].start);\n  const aEnd   = timeToMinutes(ca.appointments[ca.appointments.length-1].end);\n  const bStart = timeToMinutes(cb.appointments[0].start);\n  const bEnd   = timeToMinutes(cb.appointments[cb.appointments.length-1].end);\n  return Math.abs(aStart - bStart) <= gap && Math.abs(aEnd - bEnd) <= gap &&\n         ca.appointments[0].date === cb.appointments[0].date;\n}\n\nfunction dedupeCombosByWindowAndServices(scoredCombos){\n  const buckets = new Map();\n  for (const c of scoredCombos){\n    const day = c.appointments[0].date;\n    const svcKey = serviceMultisetSignature(c);\n    const key = `${day}::${svcKey}`;\n    const prev = buckets.get(key);\n    if (!prev){\n      buckets.set(key, c);\n      continue;\n    }\n    if (areWindowsNear(prev, c, MIN_NEAR_DUP_GAP_MIN)){\n      buckets.set(key, (c.score > prev.score) ? c : prev);\n    }else{\n      const altKey = `${key}::${comboWindowSignature(c)}`;\n      const existing = buckets.get(altKey);\n      if (!existing || c.score > existing.score) buckets.set(altKey, c);\n    }\n  }\n  return Array.from(buckets.values());\n}\n\nfunction nearestByStart(slots, targetMin){\n  return [...slots].sort((a,b)=>{\n    const da=Math.abs(timeToMinutes(a.start)-targetMin);\n    const db=Math.abs(timeToMinutes(b.start)-targetMin);\n    if (da!==db) return da-db;\n    return timeToMinutes(a.start)-timeToMinutes(b.start);\n  });\n}\n\nfunction pickDistinctByGap(candidates, minGapMin=MIN_PRESENT_GAP_MIN, limit=3){\n  const byTimeWindow = {\n    morning: [],\n    noon: [],\n    afternoon: [],\n    evening: []\n  };\n  \n  for (const c of candidates) {\n    const startTime = c.start || c.appointments?.[0]?.start;\n    if (startTime) {\n      const window = getTimeWindow(startTime);\n      if (byTimeWindow[window]) {\n        byTimeWindow[window].push(c);\n      }\n    }\n  }\n  \n  const picked = [];\n  \n  for (const window of Object.keys(byTimeWindow)) {\n    if (byTimeWindow[window].length > 0) {\n      picked.push(byTimeWindow[window][0]);\n      if (picked.length >= limit) break;\n    }\n  }\n  \n  if (picked.length < limit) {\n    for (const c of candidates) {\n      if (picked.some(p => p === c)) continue;\n      \n      const cTime = c.start || c.appointments?.[0]?.start;\n      const cDate = c.date || c.appointments?.[0]?.date;\n      \n      const clash = picked.some(p => {\n        const pTime = p.start || p.appointments?.[0]?.start;\n        const pDate = p.date || p.appointments?.[0]?.date;\n        \n        return pDate === cDate && Math.abs(timeToMinutes(pTime) - timeToMinutes(cTime)) < minGapMin;\n      });\n      \n      if (!clash) {\n        picked.push(c);\n        if (picked.length >= limit) break;\n      }\n    }\n  }\n  \n  return picked;\n}\n\nfunction generateSingleServiceAlternatives(serviceName, preferredExpert, dateStr, targetTime, existingAppointments, staffLeaves, serviceInfo, filters, currentTime=null) {\n  const candidates = [];\n  const targetMin = timeToMinutes(targetTime);\n  \n  let allExperts = eligibleExpertsForService(serviceName, serviceInfo);\n  \n  if (filters?.nail_expert_strict && Array.isArray(filters.allowed_nail_experts) && filters.allowed_nail_experts.length) {\n    const allowedCanon = filters.allowed_nail_experts.map(canonicalExpert);\n    allExperts = allExperts.filter(ex => allowedCanon.some(a => normalizeExpertName(a) === normalizeExpertName(ex)));\n  }\n\n  for (const ex of allExperts.filter(e => !preferredExpert || normalizeExpertName(e) !== normalizeExpertName(preferredExpert))) {\n    const slots = findAvailableSlots(dateStr, ex, { name: serviceName }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime);\n    const hit = slots.find(sl => timeToMinutes(sl.start) === targetMin);\n    if (hit) {\n      const det = getServiceDetails(serviceInfo, serviceName, ex);\n      if (!det) continue;\n      candidates.push({\n        date: dateStr,\n        start: hit.start,\n        end: hit.end,\n        service: serviceName,\n        expert: canonicalExpert(ex),\n        price: parseInt(det.fiyat),\n        duration: parseInt(det.sure),\n        reason: \"Aynı saat – farklı uzman\",\n        priority: 1,\n        time_window: getTimeWindow(hit.start)\n      });\n    }\n  }\n\n  if (preferredExpert) {\n    const pSlots = findAvailableSlots(dateStr, preferredExpert, { name: serviceName }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime);\n    \n    const timeWindows = [\"morning\", \"noon\", \"afternoon\", \"evening\"];\n    for (const window of timeWindows) {\n      const windowSlots = pSlots.filter(sl => getTimeWindow(sl.start) === window);\n      \n      if (windowSlots.length > 0) {\n        const sorted = nearestByStart(windowSlots, targetMin);\n        const slotsWithDifferentTimes = sorted.filter(sl => timeToMinutes(sl.start) !== targetMin);\n        \n        if (slotsWithDifferentTimes.length > 0) {\n          const selected = slotsWithDifferentTimes[0];\n          const det = getServiceDetails(serviceInfo, serviceName, preferredExpert);\n          if (!det) continue;\n          \n          const windowName = window === 'morning' ? 'Sabah' : \n                             window === 'noon' ? 'Öğle' : \n                             window === 'afternoon' ? 'Öğleden sonra' : 'Akşam';\n          \n          candidates.push({\n            date: dateStr,\n            start: selected.start,\n            end: selected.end,\n            service: serviceName,\n            expert: preferredExpert,\n            price: parseInt(det.fiyat),\n            duration: parseInt(det.sure),\n            reason: `${windowName} saati – tercih edilen uzman`,\n            priority: 2,\n            time_window: window\n          });\n        }\n      }\n    }\n  }\n\n  if (preferredExpert) {\n    const base = parseTurkishDate(dateStr);\n    const latestDate = filters?.latest_date ? parseTurkishDate(filters.latest_date) : null;\n    const maxDays = latestDate \n      ? Math.ceil((latestDate - base) / (1000 * 60 * 60 * 24))\n      : 7;\n    \n    for (let i = 1; i <= Math.min(maxDays, 14); i++) {\n      const next = new Date(base);\n      next.setDate(next.getDate() + i);\n      if (next.getDay() === WORKING_HOURS.closed_day) continue;\n      const nd = formatTurkishDate(next);\n      \n      const targetWindows = filters?.time_window\n        ? [getTimeWindowName(filters.time_window.start)]\n        : [\"morning\", \"afternoon\"];\n      \n      for (const window of targetWindows) {\n        const nSlots = findAvailableSlots(nd, preferredExpert, { name: serviceName }, existingAppointments, staffLeaves, serviceInfo, filters, null)\n          .filter(sl => getTimeWindow(sl.start) === window);\n        \n        if (nSlots.length > 0) {\n          const selected = nSlots[0];\n          const det = getServiceDetails(serviceInfo, serviceName, preferredExpert);\n          if (!det) continue;\n          \n          const windowName = window === 'morning' ? 'sabah' : \n                            window === 'noon' ? 'öğle' : \n                            window === 'afternoon' ? 'öğleden sonra' : 'akşam';\n          \n          candidates.push({\n            date: nd,\n            start: selected.start,\n            end: selected.end,\n            service: serviceName,\n            expert: preferredExpert,\n            price: parseInt(det.fiyat),\n            duration: parseInt(det.sure),\n            reason: i === 1 ? `Ertesi gün – ${windowName}` : `${i} gün sonra – ${windowName}`,\n            priority: 3 + i,\n            time_window: window\n          });\n          \n          break;\n        }\n      }\n      \n      if (candidates.length >= 3) break;\n    }\n  }\n\n  return pickDistinctByGap(candidates, MIN_PRESENT_GAP_MIN, 3);\n}\n\nfunction generateMultiServiceAlternatives(services, dateStr, targetTime, existingAppointments, staffLeaves, serviceInfo, constraints, currentTime=null) {\n  const candidates = [];\n  const filters = constraints?.filters || {};\n  const sameDayRequired = constraints?.same_day_required !== false;\n  \n  const mainService = services.find(s => isNailAnchor(s.name)) || services[0];\n  const otherServices = services.filter(s => s !== mainService);\n  const preferredExpert = mainService.expert_preference ? canonicalExpert(mainService.expert_preference) : null;\n  \n  let allExperts = eligibleExpertsForService(mainService.name, serviceInfo);\n  \n  const originalStrict = filters?.nail_expert_strict;\n  const softFilters = { ...filters, nail_expert_strict: false };\n  \n  const timeWindows = [\"morning\", \"noon\", \"afternoon\", \"evening\"];\n  \n  for (const timeWindow of timeWindows) {\n    const windowStart = timeWindow === \"morning\" ? TIME_WINDOWS.MORNING.start :\n                         timeWindow === \"noon\" ? TIME_WINDOWS.NOON.start :\n                         timeWindow === \"afternoon\" ? TIME_WINDOWS.AFTERNOON.start :\n                         TIME_WINDOWS.EVENING.start;\n    \n    const windowEnd = timeWindow === \"morning\" ? TIME_WINDOWS.MORNING.end :\n                       timeWindow === \"noon\" ? TIME_WINDOWS.NOON.end :\n                       timeWindow === \"afternoon\" ? TIME_WINDOWS.AFTERNOON.end :\n                       TIME_WINDOWS.EVENING.end;\n    \n    const windowFilters = {\n      ...softFilters,\n      time_window: {\n        start: minutesToTime(windowStart),\n        end: minutesToTime(windowEnd)\n      },\n      time_window_strict: true\n    };\n    \n    if (preferredExpert) {\n      const slots = findAvailableSlots(\n        dateStr, \n        preferredExpert, \n        mainService, \n        existingAppointments, \n        staffLeaves, \n        serviceInfo, \n        windowFilters,\n        currentTime\n      );\n      \n      if (slots.length > 0) {\n        const mainDet = getServiceDetails(serviceInfo, mainService.name, preferredExpert);\n        if (!mainDet) continue;\n        \n        const refSlot = {\n          date: dateStr,\n          expert: preferredExpert,\n          service: mainService.name,\n          start: slots[0].start,\n          end: slots[0].end,\n          duration: parseInt(mainDet.sure),\n          price: parseInt(mainDet.fiyat),\n          for_person: mainService.for_person || null\n        };\n        \n        const combo = tryScheduleAllServices(\n          refSlot,\n          otherServices,\n          { type: 'specific', value: dateStr, search_range: `${dateStr} to ${dateStr}` },\n          existingAppointments,\n          staffLeaves,\n          serviceInfo,\n          { ...constraints, filters: softFilters, same_day_required: sameDayRequired },\n          currentTime\n        );\n        \n        if (combo && combo.complete) {\n          const windowName = timeWindow === 'morning' ? 'Sabah' : \n                             timeWindow === 'noon' ? 'Öğle' : \n                             timeWindow === 'afternoon' ? 'Öğleden sonra' : 'Akşam';\n                             \n          candidates.push({\n            ...combo,\n            reason: `${windowName} saati – tercih edilen uzman`,\n            priority: 1,\n            time_window: timeWindow\n          });\n          \n          continue;\n        }\n      }\n    }\n    \n    for (const ex of allExperts.filter(e => e !== preferredExpert)) {\n      const slots = findAvailableSlots(\n        dateStr, \n        ex, \n        mainService, \n        existingAppointments, \n        staffLeaves, \n        serviceInfo, \n        windowFilters,\n        currentTime\n      );\n      \n      if (slots.length > 0) {\n        const mainDet = getServiceDetails(serviceInfo, mainService.name, ex);\n        if (!mainDet) continue;\n        \n        const refSlot = {\n          date: dateStr,\n          expert: canonicalExpert(ex),\n          service: mainService.name,\n          start: slots[0].start,\n          end: slots[0].end,\n          duration: parseInt(mainDet.sure),\n          price: parseInt(mainDet.fiyat),\n          for_person: mainService.for_person || null\n        };\n        \n        const combo = tryScheduleAllServices(\n          refSlot,\n          otherServices,\n          { type: 'specific', value: dateStr, search_range: `${dateStr} to ${dateStr}` },\n          existingAppointments,\n          staffLeaves,\n          serviceInfo,\n          { ...constraints, filters: softFilters, same_day_required: sameDayRequired },\n          currentTime\n        );\n        \n        if (combo && combo.complete) {\n          const windowName = timeWindow === 'morning' ? 'Sabah' : \n                             timeWindow === 'noon' ? 'Öğle' : \n                             timeWindow === 'afternoon' ? 'Öğleden sonra' : 'Akşam';\n                             \n          candidates.push({\n            ...combo,\n            reason: `${windowName} saati – alternatif uzman`,\n            priority: 2,\n            time_window: timeWindow\n          });\n          \n          break;\n        }\n      }\n    }\n  }\n  \n  if (preferredExpert) {\n    const base = parseTurkishDate(dateStr);\n    const latestDate = filters?.latest_date ? parseTurkishDate(filters.latest_date) : null;\n    const maxDays = latestDate \n      ? Math.ceil((latestDate - base) / (1000 * 60 * 60 * 24))\n      : 7;\n    \n    for (let i = 1; i <= Math.min(maxDays, 14); i++) {\n      const next = new Date(base);\n      next.setDate(next.getDate() + 1);\n      if (next.getDay() === WORKING_HOURS.closed_day) continue;\n      const nd = formatTurkishDate(next);\n      \n      for (const timeWindow of [\"morning\", \"afternoon\"]) {\n        const windowStart = timeWindow === \"morning\" ? TIME_WINDOWS.MORNING.start : TIME_WINDOWS.AFTERNOON.start;\n        const windowEnd = timeWindow === \"morning\" ? TIME_WINDOWS.MORNING.end : TIME_WINDOWS.AFTERNOON.end;\n        \n        const windowFilters = {\n          ...softFilters,\n          time_window: {\n            start: minutesToTime(windowStart),\n            end: minutesToTime(windowEnd)\n          },\n          time_window_strict: true\n        };\n        \n        const slots = findAvailableSlots(\n          nd, \n          preferredExpert, \n          mainService, \n          existingAppointments, \n          staffLeaves, \n          serviceInfo, \n          windowFilters,\n          null\n        );\n        \n        if (slots.length > 0) {\n          const mainDet = getServiceDetails(serviceInfo, mainService.name, preferredExpert);\n          if (!mainDet) continue;\n          \n          const refSlot = {\n            date: nd,\n            expert: preferredExpert,\n            service: mainService.name,\n            start: slots[0].start,\n            end: slots[0].end,\n            duration: parseInt(mainDet.sure),\n            price: parseInt(mainDet.fiyat),\n            for_person: mainService.for_person || null\n          };\n          \n          const combo = tryScheduleAllServices(\n            refSlot,\n            otherServices,\n            { type: 'specific', value: nd, search_range: `${nd} to ${nd}` },\n            existingAppointments,\n            staffLeaves,\n            serviceInfo,\n            { ...constraints, filters: softFilters, same_day_required: sameDayRequired },\n            null\n          );\n          \n          if (combo && combo.complete) {\n            const windowName = timeWindow === 'morning' ? 'sabah' : 'öğleden sonra';\n            \n            candidates.push({\n              ...combo,\n              reason: i === 1 ? `Ertesi gün ${windowName} – tercih edilen uzman` : `${i} gün sonra ${windowName} – tercih edilen uzman`,\n              priority: 3 + i,\n              time_window: timeWindow\n            });\n            \n            break;\n          }\n        }\n      }\n      \n      if (candidates.length >= 3) break;\n    }\n  }\n  \n  if (originalStrict && preferredExpert) {\n    candidates.forEach(c => {\n      const mainApt = c.appointments.find(a => a.service === mainService.name);\n      if (mainApt && normalizeExpertName(mainApt.expert) !== normalizeExpertName(preferredExpert)) {\n        c.priority += 10;\n        c.reason = `${c.reason} (alternatif uzman)`;\n      }\n    });\n  }\n  \n  const selected = [];\n  const timeWindowGroups = {};\n  \n  candidates.forEach(c => {\n    const window = c.time_window || \"other\";\n    if (!timeWindowGroups[window]) timeWindowGroups[window] = [];\n    timeWindowGroups[window].push(c);\n  });\n  \n  for (const window of Object.keys(timeWindowGroups)) {\n    if (timeWindowGroups[window].length > 0) {\n      const sorted = timeWindowGroups[window].sort((a, b) => {\n        if (a.priority !== b.priority) return a.priority - b.priority;\n        return 0;\n      });\n      \n      selected.push(sorted[0]);\n      \n      if (selected.length >= 3) break;\n    }\n  }\n  \n  if (selected.length < 3) {\n    const sorted = candidates\n      .filter(c => !selected.includes(c))\n      .sort((a, b) => {\n        if (a.priority !== b.priority) return a.priority - b.priority;\n        return 0;\n      });\n    \n    for (const c of sorted) {\n      const conflict = selected.some(s => \n        s.appointments[0].date === c.appointments[0].date && \n        !isTimeGapSufficient(s.appointments[0].start, c.appointments[0].start, MIN_PRESENT_GAP_MIN)\n      );\n      \n      if (!conflict) {\n        selected.push(c);\n        if (selected.length >= 3) break;\n      }\n    }\n  }\n  \n  return selected;\n}\n\nfunction generateFollowUpQuestion(options) {\n  if (options.length === 0) return \"Koşullarınıza uygun boşluk bulamadım. Saat aralığını veya uzman tercihini esnetmemi ister misiniz?\";\n  if (options.length === 1) return \"Bu seçeneği onaylıyor musunuz?\";\n  return \"Hangisini tercih edersiniz?\";\n}\n\n// ============================================\n// BÖLÜM 16: ✨ ANA FONKSİYON (OUTPUT FORMATI GÜNCELLENDİ)\n// ============================================\n\nfunction main() {\n  const input = $input.all()[0].json;\n\n  const services = (input.services || []).map(s => ({ ...s, name: normalizeServiceName(s.name) }));\n  const serviceInfoRaw = input.service_info || {};\n  const serviceInfo = Object.fromEntries(Object.entries(serviceInfoRaw).map(([k,v]) => [normalizeServiceName(k), v]));\n  const dateInfo = input.date_info;\n  const constraints = input.constraints || {};\n  const existingAppointments = input.existing_appointments || [];\n  const staffLeaves = input.staff_leaves || [];\n  \n  const currentTime = input.current_time || null;\n  \n  if (dateInfo.type === 'urgent' && currentTime) {\n    const urgentDate = parseTurkishDate(dateInfo.value);\n    const today = new Date();\n    const isToday = urgentDate.getDate() === today.getDate() && \n                    urgentDate.getMonth() === today.getMonth() && \n                    urgentDate.getFullYear() === today.getFullYear();\n    \n    if (isToday) {\n      const currentTimeMin = timeToMinutes(currentTime);\n      const closingTimeMin = timeToMinutes(WORKING_HOURS.end);\n      const minServiceDuration = 30;\n      \n      if (currentTimeMin >= closingTimeMin - minServiceDuration) {\n        console.log('⚠️ Urgent: Çalışma saati bitmiş veya çok az kaldı, otomatik olarak yarını da dahil ediyorum');\n        const tomorrow = new Date(urgentDate);\n        tomorrow.setDate(tomorrow.getDate() + 1);\n        const nextWeek = new Date(urgentDate);\n        nextWeek.setDate(nextWeek.getDate() + 7);\n        \n        dateInfo.search_range = `${dateInfo.value} to ${formatTurkishDate(nextWeek)}`;\n        dateInfo.type = 'range';\n        dateInfo.preference = 'earliest';\n      }\n    }\n  }\n\n  const effectiveConstraints = buildEffectiveConstraints(dateInfo, constraints, services);\n  const filters = effectiveConstraints.filters || {};\n\n  const dates = parseDateInfo(dateInfo);\n  const nonSundayDates = dates.filter(d => d.getDay() !== WORKING_HOURS.closed_day);\n  if (nonSundayDates.length === 0) {\n    return [{ json: { status: \"closed_day\", message: \"Salonumuz Pazar günleri kapalıdır. Lütfen başka bir gün seçiniz.\", options: [] } }];\n  }\n\n  const singleService = (services.length === 1);\n  const isSpecificDate = (dateInfo?.type === 'specific');\n  const targetTime = dateInfo?.target_time || null;\n  \n  if (singleService && isSpecificDate && targetTime) {\n    const sName = services[0].name;\n    const preferred = services[0]?.expert_preference ? canonicalExpert(services[0].expert_preference) : null;\n    const dateStr = formatTurkishDate(parseTurkishDate(dateInfo.value));\n    const targetMin = timeToMinutes(targetTime);\n\n    let exactMatch = false;\n    if (preferred) {\n      const prefSlots = findAvailableSlots(dateStr, preferred, { name: sName }, existingAppointments, staffLeaves, serviceInfo, filters, currentTime);\n      exactMatch = prefSlots.some(sl => timeToMinutes(sl.start) === targetMin);\n      \n      if (exactMatch) {\n        const slot = prefSlots.find(sl => timeToMinutes(sl.start) === targetMin);\n        const det = getServiceDetails(serviceInfo, sName, preferred);\n        if (det) {\n          const option = {\n            id: 1,\n            score: 100,\n            complete: true,\n            group_appointments: [{  // ✅ Nested format\n              for_person: services[0].for_person || \"self\",\n              appointment: {\n                date: dateStr,\n                day_name: getDayName(parseTurkishDate(dateStr)),\n                start_time: slot.start,\n                end_time: slot.end,\n                service: sName,\n                expert: preferred,\n                price: parseInt(det.fiyat),\n                duration: parseInt(det.sure)\n              }\n            }],\n            total_price: parseInt(det.fiyat),\n            total_duration: parseInt(det.sure),\n            arrangement: \"single\",\n            missing_services: []\n          };\n          \n          return [{ json: { status: \"success\", options: [option], follow_up_question: generateFollowUpQuestion([option]) } }];\n        }\n      }\n    }\n\n    if (!exactMatch) {\n      const alternatives = generateSingleServiceAlternatives(sName, preferred, dateStr, targetTime, existingAppointments, staffLeaves, serviceInfo, filters, currentTime);\n      \n      if (alternatives.length) {\n        const options = alternatives.map((c, idx) => ({\n          id: idx + 1,\n          score: null,\n          complete: true,\n          group_appointments: [{  // ✅ Nested format\n            for_person: services[0].for_person || \"self\",\n            appointment: {\n              date: c.date,\n              day_name: getDayName(parseTurkishDate(c.date)),\n              start_time: c.start,\n              end_time: c.end,\n              service: c.service,\n              expert: c.expert,\n              price: c.price,\n              duration: c.duration\n            }\n          }],\n          total_price: c.price,\n          total_duration: c.duration,\n          arrangement: \"single\",\n          missing_services: [],\n          alternative_reason: c.reason\n        }));\n\n        return [{ json: { status: \"alternatives\", options, follow_up_question: generateFollowUpQuestion(options) } }];\n      }\n    }\n  }\n\n  if (services.length > 1 && isSpecificDate) {\n    const mainService = services.find(s => isNailAnchor(s.name)) || services[0];\n    const preferred = mainService.expert_preference ? canonicalExpert(mainService.expert_preference) : null;\n    const dateStr = formatTurkishDate(parseTurkishDate(dateInfo.value));\n    const targetMin = targetTime ? timeToMinutes(targetTime) : null;\n\n    let exactMatch = false;\n    if (preferred) {\n      const mainSlots = findAvailableSlots(dateStr, preferred, mainService, existingAppointments, staffLeaves, serviceInfo, filters, currentTime);\n      const targetSlot = targetMin ? mainSlots.find(sl => timeToMinutes(sl.start) === targetMin) : mainSlots[0];\n      \n      if (targetSlot) {\n        const mainDet = getServiceDetails(serviceInfo, mainService.name, preferred);\n        if (mainDet) {\n          const refSlot = {\n            date: dateStr,\n            expert: preferred,\n            service: mainService.name,\n            start: targetSlot.start,\n            end: targetSlot.end,\n            duration: parseInt(mainDet.sure),\n            price: parseInt(mainDet.fiyat),\n            for_person: mainService.for_person || null\n          };\n          \n          const combo = tryScheduleAllServices(\n            refSlot,\n            services.filter(s => s !== mainService),\n            dateInfo,\n            existingAppointments,\n            staffLeaves,\n            serviceInfo,\n            effectiveConstraints,\n            currentTime\n          );\n          \n          if (combo && combo.complete) {\n            exactMatch = true;\n            const option = {\n              id: 1,\n              score: 100,\n              complete: true,\n              group_appointments: combo.appointments.map(apt => ({  // ✅ Nested format\n                for_person: apt.for_person || \"self\",\n                appointment: {\n                  date: apt.date,\n                  day_name: getDayName(parseTurkishDate(apt.date)),\n                  start_time: apt.start,\n                  end_time: apt.end,\n                  service: apt.service,\n                  expert: apt.expert,\n                  price: apt.price,\n                  duration: apt.duration\n                }\n              })),\n              total_price: combo.total_price,\n              total_duration: combo.total_duration,\n              arrangement: combo.arrangement,\n              missing_services: []\n            };\n            \n            return [{ json: { status: \"success\", options: [option], follow_up_question: generateFollowUpQuestion([option]) } }];\n          }\n        }\n      }\n    }\n\n    if (!exactMatch) {\n      const alternatives = generateMultiServiceAlternatives(services, dateStr, targetTime, existingAppointments, staffLeaves, serviceInfo, effectiveConstraints, currentTime);\n      \n      if (alternatives.length) {\n        const options = alternatives.map((combo, idx) => ({\n          id: idx + 1,\n          score: combo.score,\n          complete: combo.complete,\n          group_appointments: combo.appointments.map(apt => ({  // ✅ Nested format\n            for_person: apt.for_person || \"self\",\n            appointment: {\n              date: apt.date,\n              day_name: getDayName(parseTurkishDate(apt.date)),\n              start_time: apt.start,\n              end_time: apt.end,\n              service: apt.service,\n              expert: apt.expert,\n              price: apt.price,\n              duration: apt.duration\n            }\n          })),\n          total_price: combo.total_price,\n          total_duration: combo.total_duration,\n          arrangement: combo.arrangement,\n          missing_services: combo.missing_services || [],\n          alternative_reason: combo.reason\n        }));\n\n        return [{ json: { status: \"alternatives\", options, follow_up_question: generateFollowUpQuestion(options) } }];\n      }\n    }\n  }\n\n  const referenceService = services.find(s => isNailAnchor(s.name)) || services[0];\n\n  let referenceExperts = eligibleExpertsForService(referenceService.name, serviceInfo);\n\n  // ✅ IMPROVED: Tercih edilen uzmanı önceliklendir (filtrele değil)\n  const sameExpertInfo = effectiveConstraints?.same_expert_info || { sameExpert: false };\n\n  if (isNailAnchor(referenceService.name)) {\n    if (filters?.nail_expert_strict && Array.isArray(filters.allowed_nail_experts) && filters.allowed_nail_experts.length) {\n      const allowedCanon = filters.allowed_nail_experts.map(canonicalExpert);\n      referenceExperts = referenceExperts.filter(ex => allowedCanon.some(a => normalizeExpertName(a) === normalizeExpertName(ex)));\n    }\n\n    // Tercih edilen uzmanı en başa al (ama diğerlerini eleme - kullanıcı deneyimi için)\n    const pref = referenceService.expert_preference ? canonicalExpert(referenceService.expert_preference) : null;\n    if (pref) {\n      referenceExperts = [pref, ...referenceExperts.filter(e => normalizeExpertName(e) !== normalizeExpertName(pref))];\n    }\n  }\n\n  if (!referenceExperts.length) {\n    return [{ json: { status: \"error\", message: \"Seçilen hizmet için uygun uzman bulunamadı.\" } }];\n  }\n\n  const allCombinations = [];\n\n  for (const date of nonSundayDates) {\n    const dateStr = formatTurkishDate(date);\n    if (!datePassesBounds(dateStr, filters)) continue;\n\n    for (const refExpert of referenceExperts) {\n      const availableSlots = findAvailableSlots(dateStr, refExpert, referenceService, existingAppointments, staffLeaves, serviceInfo, filters, currentTime);\n\n      for (const slot of availableSlots) {\n        const serviceDetails = getServiceDetails(serviceInfo, referenceService.name, refExpert);\n        if (!serviceDetails) continue;\n\n        const combo = tryScheduleAllServices(\n          { date: dateStr, expert: canonicalExpert(refExpert), service: referenceService.name,\n            start: slot.start, end: slot.end, duration: parseInt(serviceDetails.sure), price: parseInt(serviceDetails.fiyat),\n            for_person: referenceService.for_person || null },\n          services.filter(s => s !== referenceService),\n          dateInfo, existingAppointments, staffLeaves, serviceInfo, effectiveConstraints, currentTime\n        );\n        if (!combo) continue;\n\n        const allPass = combo.appointments.every(apt => {\n          if (!datePassesBounds(apt.date, filters)) return false;\n          return withinTimeWindow({ start: apt.start, end: apt.end }, filters);\n        });\n        if (!allPass) continue;\n\n        allCombinations.push(combo);\n      }\n    }\n  }\n\n  if (allCombinations.length === 0) {\n    return [{ json: { status: \"no_availability\", message: \"Belirttiğiniz koşullara uygun boşluk bulunamadı. Uzman ve saat tercihini esnetmemi ister misiniz?\", options: [] } }];\n  }\n\n  let scored = computeScoresForAll(allCombinations, dateInfo, services);\n  scored.sort((a, b) => {\n    if (b.score !== a.score) return b.score - a.score;\n    if ((a.total_price||0) !== (b.total_price||0)) return (a.total_price||0) - (b.total_price||0);\n    const aStart = timeToMinutes(a.appointments[0].start);\n    const bStart = timeToMinutes(b.appointments[0].start);\n    return aStart - bStart;\n  });\n\n  const deduped = dedupeCombosByWindowAndServices(scored);\n\n  const topPicked = (function selectDiverseCombinations(sortedCombos, limit = 3) {\n    const selected = [];\n    const usedExperts = new Set();\n    \n    // 1. AŞAMA: Her uzmandan en iyi 1 seçenek al\n    for (const combo of sortedCombos) {\n      const expert = combo.appointments[0].expert;\n      \n      if (!usedExperts.has(expert)) {\n        selected.push(combo);\n        usedExperts.add(expert);\n        \n        if (selected.length >= limit) break;\n      }\n    }\n    \n    // 2. AŞAMA: Hala limit dolmadıysa, farklı saatlerden ekle\n    if (selected.length < limit) {\n      for (const combo of sortedCombos) {\n        // Zaten seçilmiş mi?\n        if (selected.some(sel => sel === combo)) continue;\n        \n        // Mevcut seçeneklerle zaman çakışması var mı?\n        const conflict = selected.some(sel => {\n          if (sel.appointments[0].date !== combo.appointments[0].date) return false;\n          return Math.abs(\n            timeToMinutes(sel.appointments[0].start) - \n            timeToMinutes(combo.appointments[0].start)\n          ) < MIN_PRESENT_GAP_MIN;\n        });\n        \n        if (!conflict) {\n          selected.push(combo);\n          if (selected.length >= limit) break;\n        }\n      }\n    }\n    \n    return selected;\n  })(deduped, 5);  // ✅ 3 yerine 5 seçenek\n\n  const top5 = topPicked;\n\n  // ✅ En iyi 10 seçeneği de al (sıralı liste)\n  const top10All = deduped.slice(0, 10).map((combo, index) => ({\n    id: index + 1,\n    score: combo.score,\n    complete: combo.complete,\n    group_appointments: combo.appointments.map(apt => ({\n      for_person: apt.for_person || \"self\",\n      appointment: {\n        date: apt.date,\n        day_name: getDayName(parseTurkishDate(apt.date)),\n        start_time: apt.start,\n        end_time: apt.end,\n        service: apt.service,\n        expert: apt.expert,\n        price: apt.price,\n        duration: apt.duration\n      }\n    })),\n    total_price: combo.total_price,\n    total_duration: combo.total_duration,\n    arrangement: combo.arrangement || \"single\",\n    missing_services: combo.missing_services || [],\n    alternative_message: combo.missing_services?.length > 0 ? `${combo.missing_services.join(\", \")} için farklı tarihte müsaitlik kontrolü yapabilirim.` : null\n  }));\n\n  // ✅ OUTPUT FORMATI: Nested group_appointments\n  const options = top5.map((combo, index) => ({\n    id: index + 1,\n    score: combo.score,\n    complete: combo.complete,\n    group_appointments: combo.appointments.map(apt => ({\n      for_person: apt.for_person || \"self\",\n      appointment: {\n        date: apt.date,\n        day_name: getDayName(parseTurkishDate(apt.date)),\n        start_time: apt.start,\n        end_time: apt.end,\n        service: apt.service,\n        expert: apt.expert,\n        price: apt.price,\n        duration: apt.duration\n      }\n    })),\n    total_price: combo.total_price,\n    total_duration: combo.total_duration,\n    arrangement: combo.arrangement || \"single\",\n    missing_services: combo.missing_services || [],\n    alternative_message: combo.missing_services?.length > 0 ? `${combo.missing_services.join(\", \")} için farklı tarihte müsaitlik kontrolü yapabilirim.` : null\n  }));\n\n  return [{ json: {\n    status: \"success\",\n    options,\n    top_10_all_options: top10All,  // ✅ En iyi 10 seçenek (ayrı field)\n    follow_up_question: generateFollowUpQuestion(options)\n  } }];\n}\n\nreturn main();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        256
      ],
      "id": "1665ada9-1e89-4beb-9d23-b168b0ab669c",
      "name": "Code"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  id,\n  calisan_id,\n  calisan_isim,\n  TRIM(baslangic_tarihi) as baslangic_tarihi,\n  TRIM(bitis_tarihi) as bitis_tarihi,\n  durum,\n  baslangic_saat,\n  bitis_saat\nFROM palm.calisan_izinleri\nWHERE \n  TO_DATE(TRIM(baslangic_tarihi), 'DD/MM/YYYY') <= TO_DATE('{{ $('Parse Input JSON').first().json.date_info.search_range.split(\" to \")[1] }}', 'DD/MM/YYYY')\n  AND TO_DATE(TRIM(bitis_tarihi), 'DD/MM/YYYY') >= TO_DATE('{{ $('Parse Input JSON').first().json.date_info.search_range.split(\" to \")[0] }}', 'DD/MM/YYYY')\nORDER BY calisan_isim, baslangic_tarihi;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        256,
        256
      ],
      "id": "4aeea15f-c6b1-445d-ac90-0331ac69c331",
      "name": "izinler",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "rleeqzpCZUl8KZfc",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  eventid,\n  tarih,\n  baslangic_saati,\n  bitis_saati,\n  ad_soyad,\n  hizmet_saglayici_isim,\n  hizmet,\n  hizmet_tutari\nFROM palm.randevular\nWHERE \n  TO_DATE(tarih, 'DD/MM/YYYY') >= TO_DATE('{{ $('Parse Input JSON').first().json.date_info.search_range.split(\" to \")[0] }}', 'DD/MM/YYYY')\n  AND TO_DATE(tarih, 'DD/MM/YYYY') <= TO_DATE('{{ $('Parse Input JSON').first().json.date_info.search_range.split(\" to \")[1] }}', 'DD/MM/YYYY')\n  AND hizmet_saglayici_isim IS NOT NULL\nORDER BY tarih, baslangic_saati;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        448,
        256
      ],
      "id": "6de01e21-b0f3-46a3-8ba5-0a70bbec7ca9",
      "name": "randevular",
      "alwaysOutputData": true,
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "rleeqzpCZUl8KZfc",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  uzman_adi,\n  tarih,\n  baslangic_saat,\n  bitis_saat,\n  session_id\nFROM palm.temporary_locks\nWHERE to_timestamp(expires_at, 'YYYY-MM-DD HH24:MI:SS') > (NOW() AT TIME ZONE 'Europe/Istanbul')\n  AND (\n    session_id != '{{ $('Parse Input JSON').first().json.telefon || '' }}'\n    OR (\n      session_id = '{{ $('Parse Input JSON').first().json.telefon || '' }}'\n      AND is_shown = TRUE\n    )\n  )\nORDER BY tarih, baslangic_saat;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        656,
        256
      ],
      "id": "d1453861-0f7f-48be-979c-0a4102c92fd3",
      "name": "active_locks",
      "alwaysOutputData": true,
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "rleeqzpCZUl8KZfc",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Lock Options (FIXED) — group_appointments uyumlu\n\nconst output = $('Code').first().json;\nconst telefon = $('Prepare Data for Code').first().json.telefon || '';\n\nif (!telefon) {\n  throw new Error('Telefon numarası bulunamadı!');\n}\n\n// Yardımcı: group öğesinden lock satırı çıkar\nfunction lockRowFromGroup(optionId, groupItem) {\n  // Bazı akışlarda düz appointment gelebilir; güvenli al\n  const ap = groupItem?.appointment || groupItem;\n\n  return {\n    action: 'insert',\n    telefon,                        // session_id yerine telefon\n    option_id: String(optionId),\n    uzman_adi: ap.expert,\n    tarih: ap.date,\n    baslangic_saat: ap.start_time,\n    bitis_saat: ap.end_time,\n    hizmet: ap.service,\n    is_shown: true\n  };\n}\n\nconst lockRecords = [\n  { action: 'extend_and_mark_shown', telefon } // önce mevcutları uzat/işaretle\n];\n\nconst options = Array.isArray(output?.options) ? output.options : [];\n\n// Hem success hem alternatives için aynı mantık yeterli\nfor (const option of options) {\n  const groups = option.group_appointments || option.appointments || [];\n  for (const g of groups) {\n    lockRecords.push(lockRowFromGroup(option.id, g));\n  }\n}\n\nreturn lockRecords.map(r => ({ json: r }));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1248,
        256
      ],
      "id": "7413de63-e309-425f-98e8-43010e8d0ad6",
      "name": "Lock Options"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 1
          },
          "conditions": [
            {
              "leftValue": "={{ $json.action }}",
              "rightValue": "extend_and_mark_shown",
              "operator": {
                "type": "string",
                "operation": "equals"
              },
              "id": "345f726d-079c-4c82-a202-0c2be0761905"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        1456,
        256
      ],
      "id": "5d48013e-bc8c-4a08-86f7-7df292a11dd7",
      "name": "Is Extend?"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE palm.temporary_locks\nSET \n  expires_at = to_char(\n    (NOW() AT TIME ZONE 'Europe/Istanbul') + INTERVAL '5 minutes',  -- ✅ 5 → 10\n    'YYYY-MM-DD HH24:MI:SS'\n  ),\n  is_shown = TRUE\nWHERE session_id = '{{ $json.telefon }}'\n  AND to_timestamp(expires_at, 'YYYY-MM-DD HH24:MI:SS') > (NOW() AT TIME ZONE 'Europe/Istanbul');",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1664,
        144
      ],
      "id": "9e576e3f-c947-40e9-8c60-3b5706c9669a",
      "name": "Extend and Mark Shown",
      "credentials": {
        "postgres": {
          "id": "rleeqzpCZUl8KZfc",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO palm.temporary_locks \n  (session_id, option_id, uzman_adi, tarih, baslangic_saat, bitis_saat, hizmet, is_shown, created_at, expires_at)\nVALUES \n  ('{{ $json.telefon }}',\n   '{{ $json.option_id }}', \n   '{{ $json.uzman_adi }}', \n   '{{ $json.tarih }}', \n   '{{ $json.baslangic_saat }}', \n   '{{ $json.bitis_saat }}', \n   '{{ $json.hizmet }}',\n   TRUE,\n   to_char(NOW() AT TIME ZONE 'Europe/Istanbul', 'YYYY-MM-DD HH24:MI:SS'),  -- ✅ created_at\n   to_char((NOW() AT TIME ZONE 'Europe/Istanbul') + INTERVAL '5 minutes', 'YYYY-MM-DD HH24:MI:SS'))  -- ✅ expires_at\nON CONFLICT DO NOTHING;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1664,
        352
      ],
      "id": "ddd6ef4a-085e-4131-985e-94407e055fe3",
      "name": "Insert New Locks",
      "credentials": {
        "postgres": {
          "id": "rleeqzpCZUl8KZfc",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "result",
              "name": "result",
              "value": "={{ $('Code').first().json }}",
              "type": "object"
            },
            {
              "id": "session_id",
              "name": "session_id",
              "value": "={{ $('Prepare Data for Code').first().json.telefon || '' }}",
              "type": "string"
            },
            {
              "id": "locked",
              "name": "locked",
              "value": true,
              "type": "boolean"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1872,
        256
      ],
      "id": "38541e2b-d3e7-43c3-ace8-37125eb69ad5",
      "name": "Return Final Output"
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\n\n// ✅ JSON string'lerini parse et\nconst services = typeof input.services === 'string' \n  ? JSON.parse(input.services) \n  : (input.services || []);\n\nconst serviceInfo = typeof input.service_info === 'string'\n  ? JSON.parse(input.service_info)\n  : (input.service_info || {});\n\nconst constraints = typeof input.constraints === 'string'\n  ? JSON.parse(input.constraints)\n  : (input.constraints || {});\n\n// Date info'yu parse et\nlet dateInfo = typeof input.date_info === 'string'\n  ? JSON.parse(input.date_info)\n  : (input.date_info || {});\n\n// ✅ Eğer urgent/specific ise ve search_range yoksa, oluştur\nif ((dateInfo.type === 'urgent' || dateInfo.type === 'specific') && !dateInfo.search_range) {\n  const today = new Date();\n  const targetDate = dateInfo.value || \n    `${String(today.getDate()).padStart(2, '0')}/${String(today.getMonth() + 1).padStart(2, '0')}/${today.getFullYear()}`;\n  \n  // 7 gün aralığı ver\n  const [day, month, year] = targetDate.split('/').map(Number);\n  const startDate = new Date(year, month - 1, day);\n  const endDate = new Date(startDate);\n  endDate.setDate(endDate.getDate() + 7);\n  \n  const endDateStr = `${String(endDate.getDate()).padStart(2, '0')}/${String(endDate.getMonth() + 1).padStart(2, '0')}/${endDate.getFullYear()}`;\n  \n  dateInfo.search_range = `${targetDate} to ${endDateStr}`;\n}\n\n// ✅ YENİ: Urgent için value field'ını ekle\nif (dateInfo.type === 'urgent' && !dateInfo.value) {\n  // search_range'in ilk tarihini value olarak kullan\n  if (dateInfo.search_range) {\n    dateInfo.value = dateInfo.search_range.split(' to ')[0];\n  } else {\n    // Hiç yoksa bugünü kullan\n    const today = new Date();\n    dateInfo.value = `${String(today.getDate()).padStart(2, '0')}/${String(today.getMonth() + 1).padStart(2, '0')}/${today.getFullYear()}`;\n  }\n}\n\nreturn [{\n  json: {\n    services: services,\n    service_info: serviceInfo,\n    date_info: dateInfo,\n    constraints: constraints,\n    current_time: input.current_time || '',\n    telefon: input.telefon || ''\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        48,
        256
      ],
      "id": "82d96704-d50d-44e4-9598-5432e3a5182a",
      "name": "Parse Input JSON"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "65821add-011d-4a37-850b-f22ae2ff7e00",
              "name": "services",
              "value": "={{ $('Parse Input JSON').first().json.services }}",
              "type": "array"
            },
            {
              "id": "a501c714-b1b9-44a1-88d3-a2cafa47b69f",
              "name": "service_info",
              "value": "={{ $('Parse Input JSON').first().json.service_info }}",
              "type": "object"
            },
            {
              "id": "69c825a6-76b5-45e0-97b1-fe597565fc4d",
              "name": "date_info",
              "value": "={{ $('Parse Input JSON').first().json.date_info }}",
              "type": "object"
            },
            {
              "id": "d6289a1e-8e56-40d8-bc20-99fe9ba9e04f",
              "name": "constraints",
              "value": "={{ $('Parse Input JSON').first().json.constraints }}",
              "type": "object"
            },
            {
              "id": "ff9121ea-63f6-4b76-9928-6edb0c0f3dc7",
              "name": "current_time",
              "value": "={{ $('Parse Input JSON').first().json.current_time }}",
              "type": "string"
            },
            {
              "id": "d5df0aed-498e-4f53-87d6-8f2ee62829b3",
              "name": "staff_leaves",
              "value": "={{ $('izinler').all().map(item => ({uzman_adi: item.json.calisan_isim, baslangic_tarihi: item.json.baslangic_tarihi, bitis_tarihi: item.json.bitis_tarihi, durum: item.json.durum, baslangic_saat: item.json.baslangic_saat, bitis_saat: item.json.bitis_saat})) }}",
              "type": "array"
            },
            {
              "id": "db71804c-0337-4313-9d6f-23c705e612ae",
              "name": "existing_appointments",
              "value": "={{ [...$('randevular').all().map(item => ({uzman_adi: item.json.hizmet_saglayici_isim, tarih: item.json.tarih, baslangic_saat: item.json.baslangic_saati, bitis_saat: item.json.bitis_saati})), ...$('active_locks').all().map(item => ({uzman_adi: item.json.uzman_adi, tarih: item.json.tarih, baslangic_saat: item.json.baslangic_saat, bitis_saat: item.json.bitis_saat}))] }}",
              "type": "array"
            },
            {
              "id": "27504ce9-50ea-4d88-ae7b-34dfc202115d",
              "name": "telefon",
              "value": "={{ $('Parse Input JSON').first().json.telefon }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        832,
        256
      ],
      "id": "3657a922-2821-48c4-afa8-c47290524eb4",
      "name": "Prepare Data for Code",
      "executeOnce": true
    }
  ],
  "connections": {
    "availability_checker": {
      "main": [
        [
          {
            "node": "Parse Input JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Lock Options",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "izinler": {
      "main": [
        [
          {
            "node": "randevular",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "randevular": {
      "main": [
        [
          {
            "node": "active_locks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "active_locks": {
      "main": [
        [
          {
            "node": "Prepare Data for Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Lock Options": {
      "main": [
        [
          {
            "node": "Is Extend?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is Extend?": {
      "main": [
        [
          {
            "node": "Extend and Mark Shown",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Insert New Locks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extend and Mark Shown": {
      "main": [
        [
          {
            "node": "Return Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert New Locks": {
      "main": [
        [
          {
            "node": "Return Final Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Input JSON": {
      "main": [
        [
          {
            "node": "izinler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Data for Code": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {
    "availability_checker": [
      {
        "services": "[{\"name\": \"Kalıcı Oje\", \"expert_preference\": null, \"for_person\": \"self\"}, {\"name\": \"Kalıcı Oje\", \"expert_preference\": null, \"for_person\": \"other_1\"}]",
        "service_info": "{\"Kalıcı Oje\": {\"Pınar\": {\"fiyat\": \"850\", \"sure\": \"90\"}, \"Ceren\": {\"fiyat\": \"850\", \"sure\": \"120\"}}}",
        "date_info": "{\"type\": \"range\", \"search_range\": \"16/11/2025 to 23/11/2025\", \"preference\": \"earliest\"}",
        "constraints": "{\"booking_type\": \"group\", \"same_day_required\": true, \"chain_adjacent_only\": true, \"filters\": {\"time_window\": {\"start\": \"18:00\", \"end\": \"20:00\"}, \"time_window_strict\": false, \"allowed_nail_experts\": [\"Pınar\", \"Ceren\"], \"nail_expert_strict\": false}}",
        "current_time": "19:24",
        "telefon": "905312006807"
      }
    ]
  },
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "afd9177fa22bd401d1ec287c9dde7939ce50fb767c8e226f6de704d0a8fffb41"
  }
}
